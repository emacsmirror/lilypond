@c -*- coding: utf-8; mode: texinfo; documentlanguage: ja -*-

@ignore
    Translation of GIT committish: f11513f36c131dab18338d6a3a729e24a927150d

    When revising a translation, copy the HEAD committish of the
    version that you are working on.  For details, see the Contributors'
    Guide, node Updating translation committishes..
@end ignore

@c \version "2.19.22"

@c Translators: Masamichi Hosoda, Tomohiro Tatejima, Yoshiki Sawada, Hiroshi Fukuhara
@c Translation status: post-GDP

@node Tweaking output
@chapter 出力を調整する

この章では出力を変更する方法について議論します。@c
LilyPond は本当にさまざまな設定が可能です。@c
もしかすると出力のすべての部分が変更されるかもしれません。


@need 1500
@node Tweaking basics
@section 調整の基本


@node Introduction to tweaks
@subsection 調整の紹介

@q{調整} は入力ファイルの解釈中にとられるアクションを変更し、@c
譜刻される楽譜の見た目を変更するためにユーザが利用可能なさまざまな手段を指す
LilyPond の用語です。@c
いくつかの調整はとても簡単に使うことができます。@c
他の調整はもっと複雑です。@c
しかしながら、調整のために利用可能な手段を組み合わせることによって、@c
ほとんどいかなる望みの見た目を持った楽譜でも譜刻することが可能になります。

このセクションでは、調整を理解するのに必要な基礎となるコンセプトを@c
カバーします。@c
その後、コピーするだけで効果が得られる作成準備が完了している@c
さまざまなコマンドについての情報を提供し、@c
同時に、あなたがあなた自身の調整を開発する方法を学べるように@c
それらのコマンドがどのように構築されるのかを示します。

この章を読み始める前に、あなたは @ref{Contexts and engravers} を@c
再読することを望むかもしれません。@c
なぜなら、コンテキスト、エングラーバとそれらの中に含まれるプロパティは@c
調整について理解し、調整を構成するための基礎だからです。

@node Objects and interfaces
@subsection オブジェクトとインタフェイス

@cindex object (オブジェクト)
@cindex grob (グラフィカル オブジェクト)
@cindex spanner (スパナ)
@cindex interface (インタフェイス)
@cindex properties, object (オブジェクト プロパティ)
@cindex object properties (オブジェクト プロパティ)
@cindex layout object (レイアウト プロパティ)
@cindex object, layout (レイアウト プロパティ)

調整には LilyPond プログラムの内部オペレーションと構造体への変更も含まれます。@c
そのため、我々はまずそれらの内部オペレーションと構造体を記述するために@c
使用されるいくつかの用語を導入しなければなりません。

@q{オブジェクト} という用語は入力ファイルを処理している最中に LilyPond に@c
よってビルドされる多くの内部構造体を参照するために使われる汎用的な用語です。@c
LilyPond が @code{\new Staff} のようなコマンドに遭遇した場合、@c
タイプ @code{Staff} の新しいオブジェクトを構築します。@c
その @code{Staff} オブジェクトは、その譜のコンテキスト内部で機能するために@c
割り当てられているエングラーバの詳細とともに、その譜に関連付けられている@c
すべてのプロパティ -- 例えば、その譜の名前、調号 -- を保持します。@c
同様に、@code{Voice} オブジェクト、@code{Score} オブジェクト、@c
@code{Lyrics} オブジェクトなどの他のすべてのコンテキストのプロパティを@c
保持するためのオブジェクトが存在し、さらに、小節線、符頭、タイ、強弱記号などの@c
すべての記譜要素を表すためのオブジェクトも存在します。@c
各オブジェクトはそれ自体のプロパティ値のセットを持ちます。

いくつかのタイプのオブジェクトには特別な名前が与えられています。@c
符頭、符幹、スラー、タイ、運指記号、音部記号などの譜刻される出力上の記譜要素を@c
表すオブジェクトは @q{レイアウト オブジェクト} と呼ばれ、@c
しばしば @q{グラフィカル オブジェクト}
あるいは短くして @q{グロッブ (Grob: GRaphical OBject)} と呼ばれます。@c
これらのオブジェクトも上記の汎用的な観点から見るとオブジェクトであり、@c
それゆえ、それらもまたそれらのオブジェクトに関連付けされたプロパティ --
そのオブジェクトの位置、サイズ、色など -- を持ちます。

いくつかのレイアウト オブジェクトも特別です。@c
フレージング スラー、クレッシェンド、オッターバ記号、@c
他の多くのグラフィカル オブジェクトが置かれる場所は一点ではありません
 -- それらは開始点、終了点、そしておそらくそれらの形に関係する@c
他のプロパティを持ちます。@c
これらのオブジェクトのように形が伸長されるオブジェクトは
@q{スパナ (Spanners)} と呼ばれます。

スパナは生成された後に調整を行うことができません。楽譜全体にわたって続く
@code{StaffSymbol} や @code{LedgerLineSpanner} も同様です。ただし、
@code{\stopStaff} コマンドによって終了し、@code{\startStaff} コマンドで新たに@c
生成された場合を除きます。

また、@q{抽象 (abstract)} グラフィカル オブジェクトというものも存在します。@c
これはオブジェクト自身は出力に何も書き出しませんが、他のグラフィカル
オブジェクトを収集し、配置や管理をする役割を担います。
@code{DynamicLineSpanner}, @code{BreakAlignment},
@code{NoteColumn}, @code{VerticalAxisGroup},
@code{NonMusicalPaperColumn} などが例です。後で、これらがどのように@c
使われるかを見ていきましょう。

@q{インタフェイス} とは何なのかという説明が残っています。@c
多くのオブジェクト -- たとえそれらが非常に異なっていたとしても --
は同じ方法で処理される必要がある共通特徴を共有します。@c
例えば、すべてのグラフィカル オブジェクトは色、サイズ、位置などを持ち、@c
これらのプロパティはすべて LilyPond が入力ファイルを構文解釈する最中に@c
同じ方法で処理されます。@c
これらの内部オペレーションを簡潔にするために、これらの共通アクションと@c
プロパティは 1 つのグループとして
@code{grob-interface} と呼ばれるオブジェクトにまとめられています。@c
これと同じような共有プロパティのグループ化が他にも多くあり、@c
それぞれに対して最後に @code{interface} が付く名前が与えられています。@c
そのようなインタフェイスの総数は 100 を越えます。@c
我々は後でなぜこれがユーザにとって利益となり、役に立つのかを見ていきます。

これらは、我々がこの章で使用するオブジェクトと関係する主要な用語です。

@node Naming conventions of objects and properties
@subsection オブジェクトとプロパティの命名規則

@cindex naming conventions for objects (オブジェクトの命名規則)
@cindex naming conventions for properties (プロパティの命名規則)
@cindex objects, naming conventions (オブジェクトの命名規則)
@cindex properties, naming conventions (プロパティの命名規則)

我々は以前にも @ref{Contexts and engravers} で@c
いくつかのオブジェクト命名規則を見てきました。@c
ここで参照のために、最も一般的なオブジェクトとプロパティをリストアップし、@c
それに加えてそれらの命名規則と実際の名前の例を挙げます。@c
何らかの大文字のアルファベットを表すために @q{A} を使用し、@c
いくつかの小文字のアルファベットを表すために @q{aaa} を使用しています。@c
他の文字は実際の命名でもそのまま使用されます。

@multitable @columnfractions .33 .33 .33
@headitem オブジェクト/プロパティのタイプ
  @tab 命名規則
  @tab 例
@item コンテキスト
  @tab Aaaa や AaaaAaaaAaaa
  @tab Staff, GrandStaff
@item レイアウト オブジェクト
  @tab Aaaa や AaaaAaaaAaaa
  @tab Slur, NoteHead
@item エングラーバ
  @tab Aaaa_aaa_engraver
  @tab Clef_engraver, Note_heads_engraver
@item インタフェイス
  @tab aaa-aaa-interface
  @tab grob-interface, break-aligned-interface
@item コンテキスト プロパティ
  @tab aaa や aaaAaaaAaaa
  @tab alignAboveContext, skipBars
@item レイアウト オブジェクト プロパティ
  @tab aaa や aaa-aaa-aaa
  @tab direction, beam-thickness
@end multitable

これから見ていくのですが、タイプが異なるオブジェクトのプロパティは@c
異なるコマンドによって変更されます。@c
そのため、名前からオブジェクトやプロパティのタイプを識別できるように@c
なると役に立ちます。

@morerefs
記譜法リファレンス:
@rnotationnamed{Modifying properties, プロパティを変更する}


@need 1500
@node Tweaking methods
@subsection 調整手段

@cindex tweaking methods (調整手段)


@node The override command
@unnumberedsubsubsec @code{\override} コマンド

@cindex override command (override コマンド)
@cindex override syntax (override 構文)

@funindex \override

我々はすでに @ref{Modifying context properties} と
@ref{Adding and removing engravers} で @strong{コンテキスト} のプロパティを@c
変更したり、@strong{エングラーバ} を追加/削除したりするために使用するコマンド
@code{\set} と @code{\with} を見てきました。@c
ここでは更に重要ないくつかのコマンドについて見ていきます。

@strong{レイアウト オブジェクト} のプロパティを変更するためのコマンドは
@code{\override} です。@c
このコマンドは LilyPond の奥深くにある内部プロパティを@c
変更しなければならないため、@c
これまで見てきたコマンドのように単純な構文ではありません。@c
どのコンテキストの中にあるどのオブジェクトのどのプロパティを@c
変更しなければならないのか、そこにセットする新しい値を何にするのかを@c
正確に知っている必要があります。@c
どのようにこれを行うのかを見ていきましょう。

このコマンドの一般的な構文は以下のようなものです:

@example
\override @var{Context}.@var{LayoutObject}.@var{layout-property} = #@var{value}
@end example

@noindent
これは @var{Context} コンテキストのメンバである
@var{LayoutObject} という名前のレイアウトの
@var{layout-property} という名前のプロパティに値 @var{value} をセットします。

必要とされているコンテキストが明白であり、それが最下位レベルのコンテキストである
-- つまり、@code{Voice}, @code{ChordNames} や @code{Lyrics} である
-- 場合、その @var{Context} は省略可能であり (そして通常は省略されます)、@c
この後の例の多くでも省略します。@c
後ほど、コンテキストを指定しなければならない場合について見ていきます。

これから後のセクションでは広範囲に亘るプロパティとそれらの値を扱います
-- @ref{Types of properties} を参照してください。@c
しかしながら、このセクションではそれらのフォーマットとコマンドの使い方を示す@c
ために、容易に理解できる簡単なプロパティと値をいくつか使用してみるだけです。

LilyPond の基本的な表記は文字列やマークアップだけでなく、@c
音符や演奏時間のような音楽要素です。@c
数字、シンボル、リストなどのより具体的な表記は @q{Scheme モード}
で処理されます -- 表記の先頭に @samp{#} を記述することでこのモードが@c
呼び出されます。@c
Scheme モードについての更なる情報は @rextend{LilyPond Scheme syntax}
を参照してください。

@code{\override} は調整で用いられる最も一般的なコマンドであり、@c
本章の残りの大半を使ってこのコマンドの使用例を示します。@c
まずは符頭の色を変更する簡単な例を挙げます:

@cindex color property, example (color プロパティの例)
@cindex NoteHead, example of overriding (NoteHead をオーバライドする例)

@lilypond[quote,ragged-right,verbatim]
\relative {
  c'4 d
  \override NoteHead.color = #red
  e4 f |
  \override NoteHead.color = #green
  g4 a b c |
}
@end lilypond


@node The revert command
@unnumberedsubsubsec @code{\revert} コマンド

@cindex revert command (revert コマンド)

@funindex \revert

一旦オーバライドされると、そのプロパティは再度オーバライドされるか
@code{\revert} コマンドに遭遇するまで新しい値のままでいます。@c
@code{\revert} コマンドは以下の構文を持ち、@c
プロパティの値をオリジナルのデフォルト値に戻します。@c
何度か @code{\override} コマンドが発行されている場合は、@c
前の値に戻すわけではないということに注意してください。

@example
\revert @var{Context}.@var{LayoutObject}.@var{layout-property}
@end example

繰り返しますが、@code{\override} コマンドでの @var{Context} と同様に、@c
多くの場合で @var{Context} を記述する必要はありません。@c
以下の例の多くで、@var{Context} は省略されます。@c
ここでは、最後の 2 つの音符の符頭の色をデフォルトに戻します:

@cindex color property, example (color プロパティの例)
@cindex NoteHead, example of overriding (NoteHead をオーバライドする例)

@lilypond[quote,ragged-right,verbatim]
\relative {
  c'4 d
  \override NoteHead.color = #red
  e4 f |
  \override NoteHead.color = #green
  g4 a
  \revert NoteHead.color
  b4 c |
}
@end lilypond


@node The once prefix
@unnumberedsubsubsec @code{\once} 接頭辞

@funindex \once

@code{\override}, @code{\revert}, @code{\set}, @code{\unset} コマンドには@c
接頭辞 @code{\once} が付く可能性があります。@c
これはこのようなコマンドを@c
その場一回限り有効にし、その後にそのプロパティの値をデフォルト値に戻します。@c
上と同じ例を使って、以下のように 1 つだけの音符の色を変更することができます:

@cindex color property, example (color プロパティの例)
@cindex NoteHead, example of overriding (NoteHead をオーバライドする例)

@lilypond[quote,verbatim]
\relative {
  c'4 d
  \override NoteHead.color = #red
  e4 f |
  \once \override NoteHead.color = #green
  g4 a
  \once \revert NoteHead.color
  b c |
  \revert NoteHead.color
  f2 c |
}
@end lilypond

@code{\once} 接頭辞をさまざまな定義済みコマンドの前に置くことで、@c
コマンドの効果を次の音楽タイミングに限定することもできます:

@lilypond[quote,verbatim]
\relative {
  c'4( d)
  \once \slurDashed
  e4( f) |
  g4( a)
  \once \hideNotes
  b( c) |
}
@end lilypond

@node The overrideProperty command
@unnumberedsubsubsec @code{\overrideProperty} コマンド

@cindex overrideProperty command (overrideProperty コマンド)

@funindex \overrideProperty

オーバライド コマンドには @code{\overrideProperty} という@c
もう 1 つのフォーマットがあり、時々必要となります。@c
完璧を期すためにここでこれに言及しましたが、@c
詳細は @rextend{Difficult tweaks} を参照してください。
@c Maybe explain in a later iteration  -td

@node The tweak command
@unnumberedsubsubsec @code{\tweak} コマンド

@cindex tweak command (tweak コマンド)

@funindex \tweak

利用可能な最後の調整コマンドは @code{\tweak} です。@c
これは同じ音楽タイミングで発生するいくつかのオブジェクトのうち、@c
1 つのオブジェクトだけを選択してプロパティを変更したい場合に@c
使用します
-- 例えば、和音の中にある 1 つの音符のプロパティを変更する場合です。@c
@code{\override} コマンドを使用すると和音の中にあるすべての音符に@c
影響を与えます。@c
一方、@code{\tweak} は入力ストリームの中でその @code{\tweak} の@c
すぐ後にある要素 1 つだけに影響を与えます。

ここで例を挙げます。@c
C メジャー コードの中にある真ん中の音符 (ミドル E) の符頭のサイズを@c
変更したいとします。@c
まず最初に、@code{\once \override} だとどうなるか見てみましょう:

@cindex font-size property, example (font-size プロパティの例)
@cindex NoteHead, example of overriding (NoteHead をオーバライドする例)

@lilypond[quote,ragged-right,verbatim]
\relative {
  <c' e g>4
  \once \override NoteHead.font-size = #-3
  <c e g>4
  <c e g>4
}
@end lilypond

このオーバライドは和音の中にある@emph{すべて}の符頭に影響を与えています。@c
これは和音の中にあるすべての音符が同じ @emph{タイミング} で起こるためであり、@c
@code{\once} のアクションは @code{\override} と同様に同じタイミングで起こる、@c
指定されたタイプすべてのレイアウト オブジェクトへのオーバライドに適用されます。

@code{\tweak} コマンドはこれとは異なるやり方で処理されます。@c
これは入力ストリームの中ですぐ後に続く要素にだけ作用します。@c
最もシンプルな形式の @code{\tweak} コマンドは、@c
コマンドの直後にある要素から直接作成されるオブジェクト
-- 本質的に符頭とアーティキュレーション -- にだけ効果を持ちます。@c

それでは例に戻り、この方法で和音の真ん中の音符のサイズを変更します:

@cindex font-size property, example (font-size プロパティの例)
@cindex @code{\tweak}, example (@code{\tweak} の例)

@lilypond[quote,ragged-right,verbatim]
\relative {
  <c' e g>4
  <c \tweak font-size #-3 e g>4
}
@end lilypond

@code{\tweak} の構文は @code{\override} コマンドの構文とは@c
異なるということに注意してください。@c
コンテキストを指定しません -- 実際、指定するとエラーになります。@c
コンテキストとレイアウト オブジェクトはどちらも入力ストリームの中で@c
後に続く要素によって示されます。@c
さらに、イコール記号を使うべきではないということに注意してください。@c
そのため、簡単な形式の @code{\tweak} コマンドは以下のようになります:

@example
\tweak @var{layout-property} #@var{value}
@end example

さらに、@code{\tweak} コマンドは一連のアーティキュレーションの中にある@c
ただ 1 つのアーティキュレーションを変更されるためにも使用できます。@c
ここに例を挙げます:

@cindex color property, example (color プロパティの例)
@cindex @code{\tweak}, example (@code{\tweak} の例)

@lilypond[quote,fragment,ragged-right,verbatim]
a'4^"Black"
  -\tweak color #red ^"Red"
  -\tweak color #green _"Green"
@end lilypond

@noindent
@code{\tweak} コマンドはアーティキュレーション マークの前に配置する@c
必要があることに注意してください。@c
なぜなら、調整された表記がアーティキュレーションとして適用される必要がある@c
ためです。@c
複数の向き記号 (@code{^} または @code{_}) で上書きした場合、@c
最後に適用される左端の記号が勝ち残ります。

@cindex @code{\tweak}, Accidental (臨時記号に @code{\tweak} を用いる)
@cindex @code{\tweak}, specific layout object (レイアウト オブジェクトを指定して @code{\tweak} を用いる)

符幹や臨時記号などのオブジェクトは後になってから作成されるもので、@c
@code{\tweak} コマンドの後に続くイベントから直接作成されません。@c
そのような直接作成されないオブジェクトの場合、明示的にレイアウト
オブジェクト名を指定して LilyPond がそれらのオブジェクトの起源を@c
追跡できるようにすることで、@code{\tweak} で調整することができます:

@lilypond[quote,fragment,ragged-right,verbatim]
<\tweak Accidental.color #red   cis''4
 \tweak Accidental.color #green es''
 g''>
@end lilypond

この長い形式の @code{\tweak} コマンドは以下のように記述することができます:

@example
\tweak @var{LayoutObject}.@var{layout-property} #@var{value}
@end example

@cindex tuplets, nested (ネストされた連符)
@cindex triplets, nested (ネストされた 3 連符)
@cindex bracket, tuplet (連符の囲み)
@cindex bracket, triplet (3 連符の囲み)
@cindex tuplet bracket (連符の囲み)
@cindex triplet bracket (3 連符の囲み)

@funindex TupletBracket

さらに、@code{\tweak} コマンドは、同時に起こるネストされた@c
連符記号のセットのうちの 1 つの見た目を変更するためにも使用されます。@c
以下の例では、長い連符記号と 3 つの短い連符記号のうちの最初の連符記号が@c
同時に起こります。@c
そのため、@code{\override} コマンドだと両方の連符記号に@c
適用されてしまいます。@c
この例では、@code{\tweak} は 2 つの連符記号を区別するために@c
使用されています。@c
最初の @code{\tweak} コマンドは長い連符記号を音符の上に置くことを@c
指定していて、2 番目の @code{\tweak} コマンドは最初の短い連符記号の数字を@c
赤で描くことを指定しています。

@cindex @code{\tweak}, example (@code{\tweak} の例)
@cindex direction property, example (direction プロパティの例)
@cindex color property, example (color プロパティの例)

@lilypond[quote,ragged-right,verbatim]
\relative c'' {
  \tweak direction #up
  \tuplet 3/4 {
    \tweak color #red
    \tuplet 3/2 { c8[ c c] }
    \tuplet 3/2 { c8[ c c] }
    \tuplet 3/2 { c8[ c c] }
  }
}
@end lilypond

ネストされた連符が同時に起こらない場合、それらの見た目は @code{\override}
コマンドを用いた通常通りの方法で変更されるかもしれません:

@cindex text property, example (text プロパティの例)
@cindex tuplet-number function, example (tuplet-number 関数の例)
@cindex transparent property, example (transparent プロパティの例)
@cindex TupletNumber, example of overriding (TupletNumber をオーバライドする例)

@lilypond[quote,ragged-right,verbatim]
\relative {
  \tuplet 3/2 { c'8[ c c] }
  \once \override TupletNumber.text = #tuplet-number::calc-fraction-text
  \tuplet 3/2 {
    c8[ c]
    c8[ c]
    \once \override TupletNumber.transparent = ##t
    \tuplet 3/2 { c8[ c c] }
    \tuplet 3/2 { c8[ c c] }
  }
}
@end lilypond


@morerefs
記譜法リファレンス:
@rnotation{The tweak command}

@node The single prefix
@unnumberedsubsubsec @code{\single} 接頭辞

@funindex \single
@cindex tweak, generated from override (override から生成される tweak)

特定の符頭を赤色にしてサイズを大きくすることによって、強調を行いたいと@c
しましょう。また、それを簡単にするためにこのような関数を定義したとしましょう:

@lilypond[quote,verbatim]
emphNoteHead = {
  \override NoteHead.color = #red
  \override NoteHead.font-size = 2
}
\relative {
  c''4 a \once \emphNoteHead f d |
}
@end lilypond

@code{\once} 接頭辞は単音や和音全体には動作しますが、和音@emph{内}の@c
一つの音符に対しては使うことができません。さっき、@code{\tweak} は@c
このような場面で使うということを学びました。
@ref{The tweak command} を参照してください。@c
しかし、@code{\tweak} は関数と一緒に使うことができません。そこで
@code{\single} の登場です:

@lilypond[quote,verbatim]
emphNoteHead = {
  \override NoteHead.color = #red
  \override NoteHead.font-size = 2
}
\relative {
   <c'' a \single \emphNoteHead f d>4
}
@end lilypond

要約すると、@code{\single} は @code{\override} を @code{\tweak} に変換します。@c
よって、(和音内の音符のように) 同じタイミングにいくつかのオブジェクトが@c
存在する場合、@code{\once} はその全てに影響を与えるのに対し、
@code{\single} はその内の 1 つに -- すぐ後に続く音楽表記のみに -- 作用します。

@code{\single} をこのように使用することで、@code{\override} のみから成る@c
簡略化のために定義された関数を、和音内の各音符に対して適用することができます。@c
しかし、@code{\single} は @code{\revert}, @code{\set}, @code{\unset} を
@code{\tweak} に変換することはできません。

@morerefs
学習マニュアル:
@ref{The tweak command},
@ref{Using variables for layout adjustments}


@need 1500
@node The Internals Reference manual
@section 内部リファレンス マニュアル

@cindex Internals Reference (内部リファレンス)


@node Properties of layout objects
@subsection レイアウト オブジェクトのプロパティ

@cindex properties of layout objects (レイアウト オブジェクトのプロパティ)
@cindex properties of grobs (グラフィカル オブジェクトのプロパティ)
@cindex grobs, properties of (グラフィカル オブジェクトのプロパティ)
@cindex layout objects, properties of (レイアウト オブジェクトのプロパティ)
@cindex Internals Reference manual (内部リファレンス マニュアル)

あなたがスラーを楽譜に描き、@c
そのスラーが細すぎるためにもう少し太くしたいと思ったとします。@c
どうやってスラーを太くしますか？@c
以前に LilyPond の自由度の高さについて述べたので、@c
そのようなことが可能であることは知っています。@c
あなたはおそらく @code{\override} コマンドが必要であると推測するでしょう。@c
しかしながら、スラーの太さプロパティは存在するのでしょうか？@c
そして、それが存在するならどうやって変更するのでしょうか？@c
このようなことに内部リファレンス マニュアルは触れています。@c
内部リファレンス マニュアルには、あなたがスラーを太くするために必要な情報、@c
他のすべての @code{\override} コマンドを構築するために必要な情報が@c
含まれています。

内部リファレンスを見ていく前に一言警告です。@c
これは @strong{リファレンス} ドキュメントであり、@c
説明はほんの少しかまったく含まれていません:
リファレンスの目的は情報を正確に、かつ簡潔に提供することです。@c
そのため、内部リファレンスを一見してひるんでしまうかもしれません。@c
しかし、心配しないでください！@c
ここにあるガイダンスと説明を読めば、少し練習するだけで、@c
内部リファレンスから必要な情報を取り出せるようになります。

@cindex override example (オーバライドの例)
@cindex Internals Reference, example of using (内部リファレンスの使用例)
@cindex @code{\addlyrics} example (@code{\addlyrics} の例)

実際の音楽からの簡単な断片を持つ具体例を使用していきましょう:

@c Mozart, Die Zauberflöte Nr.7 Duett

@lilypond[quote,verbatim]
{
  \key es \major
  \time 6/8
  \relative {
    r4 bes'8 bes[( g]) g |
    g8[( es]) es d[( f]) as |
    as8 g
  }
  \addlyrics {
    The man who | feels love's sweet e -- | mo -- tion
  }
}
@end lilypond

ここで、スラーをもう少し太くしようと決めたことにします。@c
それは可能でしょうか？@c
スラーは確かにレイアウト オブジェクトです。@c
そのため、その疑問は
@q{スラーに属していて、太さを制御するプロパティは存在するのか？}
ということになります。@c
その答えを得るために内部リファレンス -- 縮めて IR -- を見なければなりません。

あなたが使用しているバージョンの LilyPond のための内部リファレンスは
LilyPond ウェブサイト @uref{https://lilypond.org} で見つかるでしょう。@c
ドキュメント ページに行き、内部リファレンスへのリンクをクリックしてください。@c
学習目的のためには標準の HTML バージョンを使うべきであり、@c
@q{1 つの大きなページ} や PDF を使うべきではありません。@c
次の数段落を読めば、あなたが内部リファレンスを読むときに@c
実際にすべきことがわかるでしょう。

内部リファレンスの @strong{トップ ページ} 下には 5 つのリンクがあります。@c
@emph{Backend} へのリンクを選択してください。@c
そこにはレイアウト オブジェクトについての情報があります。@c
@strong{Backend} 下にある @emph{All layout objects} へのリンクを@c
選択してください。@c
そのページには、あなたが使用しているバージョンの LilyPond で使用される@c
すべてのレイアウト オブジェクトがアルファベット順で@c
リストアップされています。@c
Slur へのリンクを選択すると、Slur のプロパティがリスト アップされます。

記譜法リファレンスからこのページを見つける方法もあります。@c
スラーについて扱っているページで、内部リファレンスへのリンクが@c
見つかるかもしれません。@c
このリンクでこのページに直接行くことができます。@c
しかしながら、あなたが調整するレイアウト オブジェクトの名前を@c
想像できる場合は、すぐに内部リファレンスに行ってそこで探す方が簡単です。

内部リファレンスの Slur ページでは、まず Slur オブジェクトは
@code{Slur_engraver} によって作成されるということが述べられています。@c
それから、標準設定がリストアップされています。@c
スラーの太さを制御していそうなプロパティを探してブラウザをスクロール ダウン@c
させていくと、以下が見つかります:

@example
thickness (number)
     1.2
     Line thickness, generally measured in line-thickness
@end example

これが太さを変更するプロパティのようです。@c
@code{thickness} の値は @emph{数} であり、デフォルト値は 1.2、@c
この値は他のプロパティでは @code{line-thickness} と@c
呼ばれるということがわかります。

前にも言ったように、内部リファレンスには説明がほとんど、@c
あるいはまったくありません。@c
しかしながら、すでにスラーの太さを変えるための十分な情報を持っています。@c
レイアウト オブジェクトの名前は @code{Slur} であり、@c
変更するプロパティの名前は @code{thickness} であり、@c
スラーをもっと太くするには新しい値を 1.2 よりも大きくすべきであることが@c
わかります。

今度は、レイアウト オブジェクト名で見つけた値を置き換えることによって
@code{\override} コマンドを構築することができます。@c
コンテキストは省略します。@c
最初は太さに非常に大きな値を割り当ててみます。@c
それによって、そのコマンドが確かに機能していることを確かめることができます。@c
実行するコマンドは以下のようになります:

@example
\override Slur.thickness = #5.0
@end example

新しい値の前に @code{#} を付けることを忘れないでください！

最後の疑問は @q{このコマンドをどこに置くべきか？} ということです。@c
そのことについて不確かであり、学んでいる最中であるのならば、@c
ベストな答えはこうです @q{音楽表記の内部で、最初のスラーの直前}。@c
ではやってみましょう:

@cindex Slur example of overriding (Slur をオーバライドする例)
@cindex thickness property, example (thickness プロパティの例)

@lilypond[quote,verbatim]
{
  \key es \major
  \time 6/8
  \relative {
    % これ以降にある全てのスラーの太さを 1.2 から 5.0 にします
    \override Slur.thickness = #5.0
    r4 bes'8 bes[( g]) g |
    g8[( es]) es d[( f]) as |
    as8 g
  }
  \addlyrics {
    The man who | feels love's sweet e -- | mo -- tion
  }
}
@end lilypond

@noindent
確かにスラーが太くなっています。

これが @code{\override} コマンドを構築する基本的な方法です。@c
これより後のセクションで遭遇するものはもう少し複雑ですが、@c
必要な要点はすべて知っています
-- しかしながら、まだ練習が必要でしょう。@c
これは以下の例で提供されます。

@subsubsubheading コンテキストを見つけ出す

@cindex context, finding (コンテキストを見つけ出す)
@cindex context, identifying correct (正しいコンテキストを特定する)

しかしながら、まず最初にコンテキストを指定しなければならないとしたら@c
どうでしょうか？@c
指定すべきコンテキストは何でしょうか？@c
スラーとボイスは音楽表記の各行で明らかに関係が深いので、@c
スラーは @code{Voice} コンテキストの中にあると推測できるかもしれません。@c
しかし、それは確かでしょうか？@c
この問題を解決するには、Slur について記述している内部リファレンス ページの@c
先頭に戻ります。@c
そこには @q{Slur オブジェクトは Slur エングラーバによって作成される} と@c
書かれています。@c
そのため、スラーは @code{Slur_engraver} が存在しているコンテキストの@c
どれかで作成されるということになります。@c
@code{Slur_engraver} へのリンクを辿ります。@c
そのページの最後の方で @code{Slur_engraver} は 7 つのボイス コンテキスト
-- 標準のボイス コンテキストである @code{Voice} を含む
-- の一部であることが述べられています。@c
ですから、推測は正しかったのです。@c
そして、@code{Voice} は最下位のコンテキストの 1 つである
-- このことは、そこに音符を入力するという事実によって明らかに示されています
-- ため、ここではそのコンテキストを省略することができるのです。

@subsubsubheading 1 回だけオーバライドする

@cindex overriding once only (一度だけオーバライドする)
@cindex once override (一度だけオーバライドする)

@funindex \once

上記の最後の例では @emph{すべて} のスラーが太くなっています。@c
しかし、最初のスラーだけを太くしたい場合はどうでしょうか？@c
これは @code{\once} コマンドを使うことによって達成されます。@c
@code{\override} コマンドの直前に @code{\once} コマンドを@c
置くことによって、@code{\override} コマンドは @strong{直後にある} 音符から@c
始まるスラーだけを変更するようになります。@c
直後にある音符がスラーの開始点ではない場合、そのコマンドはまったく機能しません
-- それがスラーに遭遇するまで保持されるということはなく、@c
ただ切り捨てられるだけです。@c
そのため、@code{\once} コマンド付きの @code{\override} コマンドは@c
以下のように上記の例とは異なる場所に置かなくてはなりません:

@cindex Slur, example of overriding (Slur をオーバライドする例)
@cindex thickness property, example (thickness プロパティの例)

@lilypond[quote,verbatim]
{
  \key es \major
  \time 6/8
  \relative {
    r4 bes'8
    % 直後にあるスラーのみを太くします
    \once \override Slur.thickness = #5.0
    bes8[( g]) g |
    g8[( es]) es d[( f]) as |
    as8 g
  }
  \addlyrics {
    The man who | feels love's sweet e -- | mo -- tion
  }
}
@end lilypond

@noindent
今度は、最初のスラーだけが太くなりました。

@code{\once} コマンドは @code{\set} コマンドの前でも使用される可能性があります。

@subsubsubheading 元に戻す

@cindex revert (元に戻す)
@cindex default properties, reverting to (デフォルトのプロパティに戻す)

@funindex \revert

最後に、最初の 2 つだけのスラーを太くしたい場合はどうでしょうか？@c
その場合、2 つのコマンド -- それぞれの前に @code{\once} を付けた --
をスラーが始まる音符の直前に置きます:

@cindex Slur, example of overriding (Slur をオーバライドする例)
@cindex thickness property, example (thickness プロパティの例)

@lilypond[quote,verbatim]
{
  \key es \major
  \time 6/8
  \relative {
    r4 bes'8
    % 直後にあるスラーのみを太くします
    \once \override Slur.thickness = #5.0
    bes[( g]) g |
    % 直後にあるスラーのみを太くします
    \once \override Slur.thickness = #5.0
    g8[( es]) es d[( f]) as |
    as8 g
  }
  \addlyrics {
    The man who | feels love's sweet e -- | mo -- tion
  }
}
@end lilypond

@noindent
あるいは、@code{\once} コマンドを省略して、2 番目のスラーの後に
@code{thickness} プロパティをデフォルト値に戻すために
@code{\revert} コマンドを使うこともできます:

@cindex Slur, example of overriding (Slur をオーバライドする例)
@cindex thickness property, example (thickness プロパティの例)

@lilypond[quote,verbatim]
{
  \key es \major
  \time 6/8
  \relative {
    r4 bes'8
    % 以後のスラーの太さを 1.2 から 5.0 に増やします
    \override Slur.thickness = #5.0
    bes[( g]) g |
    g8[( es]) es
    % 以後のスラーの太さをデフォルトの 1.2 に戻します
    \revert Slur.thickness
    d8[( f]) as |
    as8 g
  }
  \addlyrics {
    The man who | feels love's sweet e -- | mo -- tion
  }
}
@end lilypond

@noindent
@code{\revert} コマンドは @code{\override} コマンドで@c
変更されたどのプロパティでもデフォルト値に戻すことができます。@c
状況に相応しい方を使用してください。

これで内部リファレンスと調整の基本的な方法についての紹介を終わりにします。@c
この章で後に続くセクションの中にあるいくつのかの例でも一部では、@c
内部リファレンスの特徴についての追加の紹介や、そこから情報を取り出すための@c
更なる練習を提供します。@c
それらの例ではガイダンスや説明のための言葉はずっと少ないでしょう。


@node Properties found in interfaces
@subsection インタフェイスの中で見つかるプロパティ

@cindex interface (インタフェイス)
@cindex interface properties (インタフェイス プロパティ)
@cindex properties in interfaces (インタフェイス内のプロパティ)

今度は歌詞をイタリック体で譜刻したいということにします。@c
そうするには @code{\override} コマンドをどのように使う必要があるのでしょうか？@c
以前と同様に、まず @q{すべてのレイアウト オブジェクト} をリストアップしている@c
内部リファレンス ページを開き、歌詞をコントロールしていそうなオブジェクトを@c
探します。@c
@code{LyricText} がそれであるようです。@c
これをクリックすると、歌詞のテキストに対してセットすることができる@c
プロパティが表示されます。@c
そこには @code{font-series} と @code{font-size} が含まれますが、@c
歌詞をイタリック体にするためのプロパティらしきものはありません。@c
これは、形に関するプロパティはすべてのフォント オブジェクトに共通なもの@c
であり、そのため、各レイアウト オブジェクトに含まれているのではなく、@c
他の同様な共通プロパティと一緒にグループ化されていて、@c
@strong{インタフェイス} の 1 つ @code{font-interface} の中に@c
置かれているからです。

そのため、インタフェイスのプロパティを見つける方法と、どのオブジェクトが@c
これらのインタフェイス プロパティを使うのかを調べる方法を学ぶ必要があります。

@code{LyricText} について記述している内部リファレンスのページを@c
再び開いてください。@c
そのページの最後に @code{LyricText} がサポートするインタフェイスへのリンクが@c
リスト アップされています。@c
そのリストには @code{font-interface} を含むいくつかの要素があります。@c
このリンクをクリックすると、このインタフェイスに@c
関連付けされているプロパティのところに行きます。@c
これらのプロパティは @code{LyricText} を含む @code{font-interface} を@c
サポートするすべてのオブジェクトのプロパティでもあります。

@code{font-shape(symbol)} を含むフォントを制御するユーザが@c
設定可能なプロパティをすべて見つけました。@c
@code{font-shape(symbol)} では @code{symbol} を @code{upright},
@code{italics}, あるいは @code{caps} にセットすることができます。

そこには、@code{font-series} と @code{font-size} もリスト アップされている@c
ことに気づくでしょう。@c
そこで次のような疑問が湧いてきます:
共通フォントプロパティ @code{font-series} と @code{font-size} は
@code{LyricText} とインタフェイス @code{font-interface} の両方で@c
リスト アップされているのに、なぜ @code{font-shape} はそうでないのか？@c
その答えは、@code{font-series} と @code{font-size} は、@c
@code{LyricText} オブジェクトが作成されるときに、@c
それらのグローバルなデフォルト値から変更されるのに対して、@c
@code{font-shape} はそうではないからです。@c
@code{LyricText} の中にあるエントリから @code{LyricText} に適用される@c
それら 2 つのプロパティの値がわかります。@c
@code{font-interface} をサポートする他のオブジェクトは、@c
それらのオブジェクトが作成されるときに、@c
それらのプロパティを異なる値にセットします。

今度は歌詞をイタリック体に変更するように @code{\override} コマンドを@c
構築できるかどうかを見ていきましょう。@c
オブジェクトは @code{LyricText} であり、@c
プロパティは @code{font-shape} であり、セットする値は @code{italic} です。@c
前と同様に、コンテキストを省略します。

話は逸れますが重要なことを 1 つ挙げます。@c
プロパティには値としてシンボル (例えば @code{italic}) を取るものがあります。@c
シンボルの前にはアポストロフィ @code{'} を置く必要があり、そうすることで内部的に
LilyPond に読み込まれます。@c
任意のテキスト文字列との違い -- 任意のテキスト文字列は @code{"a text string"}
のような形で表記されます -- に注意してください。@c
シンボルと文字列についてのより詳細な説明は@rextend{Scheme tutorial}
を参照してください。

さて、それでは歌詞をイタリック体で譜刻するために必要となる
@code{\override} コマンドは以下のようになります:

@example
\override LyricText.font-shape = #'italic
@end example

@noindent
そして、これは以下のように影響を与える歌詞の前に、そして近くに置くべきです:

@cindex font-shape property, example (font-shape プロパティの例)
@cindex italic, example (italic の例)
@cindex LyricText, example of overriding (Lyric をオーバライドする例)
@cindex @code{\addlyrics}, example (@code{\addlyrics} の例)

@lilypond[quote,ragged-right,verbatim]
{
  \key es \major
  \time 6/8
  \relative {
    r4 bes'8 bes[( g]) g |
    g8[( es]) es d[( f]) as |
    as8 g
  }
  \addlyrics {
    \override LyricText.font-shape = #'italic
    The man who | feels love's sweet e -- | mo -- tion
  }
}
@end lilypond

@noindent
これで歌詞がすべてイタリック体で譜刻されました。

@warning{歌詞の中では、最後の音節と終端の波括弧の間に常にスペースを@c
置いてください。}


@morerefs
拡張: @rextend{Scheme tutorial}


@node Types of properties
@subsection プロパティのタイプ

@cindex property types (プロパティ タイプ)

これまでにプロパティのタイプを 2 つ見てきました:
@code{number} と @code{symbol} です。@c
プロパティに与える値が有効であるためには、その値は正しいタイプであり、@c
そのタイプのルールに従っていなければなりません。@c
プロパティのタイプは内部リファレンスの中で常にプロパティ名の後の括弧の中に@c
表示されています。@c
ここに、あなたが必要になるであろうプロパティのタイプを、@c
そのタイプのルールといくつかの例と共にリスト アップします。@c
@code{\override} コマンドの中でプロパティの値を入力する時は、@c
当然、常にそれらの値の前にハッシュ記号 @code{#} を付け加える必要があります
-- 例え、その値自体が @code{#} で始まっていたとしても付け加える必要があり@c
ます。@c
ここでは定数の例だけを示します: Scheme を用いて値の計算をしたいのであれば、@c
@rextend{Calculations in Scheme} を参照してください。

@multitable @columnfractions .2 .45 .35
@headitem プロパティ タイプ
  @tab 規則
  @tab 例
@item Boolean
  @tab 真か偽のどちらかで、それぞれ #t と #f で表されます
  @tab @code{#t}, @code{#f}
@item Dimension (譜スペース)
  @tab 小数 (譜スペース単位)
  @tab @code{2.5}, @code{0.34}
@item Direction
  @tab 向きを表す有効な定数またはそれと等価な数値 (-1 から 1 までの小数が@c
許可されます)
  @tab @code{LEFT}, @code{CENTER}, @code{UP},
       @code{1}, @w{@code{-1}}
@item Integer
  @tab 整数
  @tab @code{3}, @code{-1}
@item List
  @tab 一連の定数またはシンボル。@c
  スペースで区切られ、前にアポストロフィが付いた括弧で囲まれます
  @tab @code{'(left-edge staff-bar)}, @code{'(1)}, @code{'()},
       @code{'(1.0 0.25 0.5)}
@item Markup
  @tab 有効なマークアップ
  @tab @code{\markup @{ \italic "cresc." @}}
@item Moment
  @tab make-moment 関数で構築される全音符の分数
  @tab @code{(ly:make-moment 1/4)},
       @code{(ly:make-moment 3/8)}
@item Number
  @tab 正または負の小数
  @tab @code{3.5}, @w{@code{-2.45}}
@item (数の) Pair
  @tab @q{スペース . スペース} で区切られ、前にアポストロフィが付いた括弧で@c
囲まれた 2 つの数値
  @tab @code{'(2 . 3.5)}, @code{'(0.1 . -3.2)}
@item Symbol
  @tab プロパティに許可されているシンボルのセットのいずれかであり、@c
前にアポロストロフィを付けます
  @tab @code{'italic}, @code{'inside}
@item Unknown
  @tab 手続き。何のアクションも起こさない場合は @code{#f}
  @tab @code{bend::print}, @code{ly:text-interface::print},
       @code{#f}
@item Vector
  @tab @code{#(}@dots{}@code{)} で囲まれたいくつかの定数
  @tab @code{#(#t #t #f)}
@end multitable


@morerefs
拡張: @rextend{Scheme tutorial}


@node Appearance of objects
@section オブジェクトの見た目

いくつかの例を使ってこれまでに学んだことを練習して、譜刻される楽譜の見た目を@c
変更するためにどのように調整が使われるのかを見ていきましょう。


@node Visibility and color of objects
@subsection オブジェクトの可視性と色

教育目的の楽譜では、ある要素を省略した楽譜を譜刻して、@c
学生にそれを付け足させるという訓練にしたいと思うかもしれません。@c
簡単な例として、その訓練とは小節線の無い楽譜だと仮定してみましょう。@c
しかしながら、通常、小節線は自動的に挿入されます。@c
どうやって小節線が譜刻されることを防ぐのでしょうか？

このことに挑戦する前に、オブジェクト プロパティは @emph{インタフェイス} と@c
呼ばれるものにグループ化されているということを思い出してください
-- @ref{Properties found in interfaces} を参照してください。@c
これはあるグラフィカル オブジェクトを調整するために一緒に@c
使用されるかもしれないプロパティをグループ化したものです
-- あるオブジェクトに対してインタフェイス内のプロパティの 1 つを使うことが@c
許可されるのなら、他のプロパティも許可されます。@c
あるオブジェクトはいくつかのインタフェイス内にあるプロパティを使用し、@c
別のオブジェクトはそれとは別のインタフェイス内にあるプロパティを使用します。@c
ある特定のグラフィカルオブジェクトによって使用されるプロパティを保持している@c
インタフェイスは、そのグラフィカル オブジェクトについて記述している@c
内部リファレンス ページの最後にリスト アップされていて、@c
それらのプロパティはそれらのインタフェイスを参照することによって閲覧できます。

グラフィカル オブジェクトについての情報を見つけ出す方法を
@ref{Properties of layout objects} で説明しました。@c
同じアプローチを使って、内部リファレンスで小節線を@c
譜刻するレイアウト オブジェクトを見つけ出します。@c
@emph{Backend} を経由して @emph{All layout objects} に行くと、@c
そこに @code{BarLine} と呼ばれる@c
レイアウト オブジェクトがあることがわかります。@c
そのレイアウト オブジェクトのプロパティには小節線の可視性をコントロールする
2 つのプロパティが含まれています: @c
@code{break-visibility} と @code{stencil} です。@c
さらに、@code{BarLine} はインタフェイスのいくつかをサポートしています。@c
@code{grob-interface} もサポートされていて、@c
そこには @code{transparent} プロパティと @code{color} プロパティが@c
含まれています。@c
これらすべてが小節線の可視性に影響を与えます (そしてもちろん、@c
拡大解釈すれば他の多くのレイアウト オブジェクトにも影響を与えます)。@c
次はこれらのプロパティをそれぞれ見ていきましょう。


@node The stencil property
@unnumberedsubsubsec @code{stencil} プロパティ

@cindex stencil property (stencil プロパティ)

このプロパティは譜刻すべきシンボル (図柄) を指定することによって@c
小節線の見た目を制御します。@c
他の多くのプロパティでも共通に言えますが、このプロパティの値に
@code{#f} をセットすることによって何も譜刻させなくすることができます。@c
ではやってみましょう。@c
以前と同様に、暗黙のコンテキスト @code{Voice} は省略します:

@cindex BarLine, example of overriding (BarLine をオーバライドする例)
@cindex stencil property, example (stencil プロパティの例)

@lilypond[quote,ragged-right,verbatim]
\relative {
  \time 12/16
  \override BarLine.stencil = ##f
  c''4 b8 c d16 c d8 |
  g,8 a16 b8 c d4 e16 |
  e8
}
@end lilypond

小節線はまだ譜刻されています。@c
何が間違っているのでしょうか？@c
内部リファレンスに戻って、@code{BarLine} のプロパティを記述しているページを@c
読み返してください。@c
そのページの先頭に
@qq{BarLine オブジェクトは Bar_engraver によって作成されます} と@c
記述されています。@c
@code{Bar_engraver} ページに行ってください。@c
そのページの最後で、@code{Bar_engraver} を保持するコンテキストが@c
リスト アップされています。@c
それらのコンテキストのタイプはすべて @code{Staff} です。@c
ですから、@code{\override} コマンドが予期したように機能しなかったのは、@c
@code{BarLine} はデフォルトの @code{Voice} コンテキストの中には@c
いなかったからなのです。@c
コンテキストが間違って指定された場合、そのコマンドは機能しません。@c
エラー メッセージは生成されず、ログ ファイルには何もログが残りません。@c
正しいコンテキストを付け加えることによってコマンドを修正してみましょう:

@cindex BarLine, example of overriding (BarLine をオーバライドする例)
@cindex stencil property, example (stencil プロパティの例)

@lilypond[quote,ragged-right,verbatim]
\relative {
  \time 12/16
  \override Staff.BarLine.stencil = ##f
  c''4 b8 c d16 c d8 |
  g,8 a16 b8 c d4 e16 |
  e8
}
@end lilypond

今度は小節線が消えました。@c
@code{stencil} プロパティに @code{#f} をセットする操作は頻繁に行うので、@c
短くしたコマンド @code{\omit} が用意されています:
@funindex \omit

@lilypond[quote,ragged-right,verbatim]
\relative {
  \time 12/16
  \omit Staff.BarLine
  c''4 b8 c d16 c d8 |
  g,8 a16 b8 c d4 e16 |
  e8
}
@end lilypond

しかしながら、@code{stencil} プロパティを @code{#f} にセットするのではなく、@c
オブジェクトの大きさを修正する必要があるオブジェクトも存在するということに@c
注意してください。@c
そのようなオブジェクトの @code{stencil} プロパティを @code{#f} にセットすると@c
エラーになります。
例えば、@code{NoteHead} オブジェクトの @code{stencil} プロパティを
@code{#f} にセットするとエラーになります。@c
この場合、@code{point-stencil} を使ってサイズが 0 のステンシル (型、型紙) を@c
オブジェクトにセットします:

@lilypond[quote,verbatim]
\relative {
  c''4 c
  \once \override NoteHead.stencil = #point-stencil
  c4 c
}
@end lilypond


@node The break-visibility property
@unnumberedsubsubsec @code{break-visibility} property

@cindex break-visibility property (break-visibility プロパティ)

内部リファレンスの @code{BarLine} のプロパティから
@code{break-visibility} プロパティには 3 つのブール値からなるベクトルが@c
必要であることがわかります。@c
これらはそれぞれ、小節線が行の最後、行の途中、行の最初に譜刻されるかどうかを@c
制御します。@c
以下の例ではすべての小節線を消したいので、必要となる値は
@code{#(#f #f #f)} です
(同じ結果を @code{all-invisible} でも得ることができます)。@c
それではやってみましょう。@c
@code{Staff} コンテキストを含めることを忘れないでください。@c
また、この値を書くときに括弧を始める前に @code{##} を@c
付ける必要があることにも注意してください。@c
@code{#} の 1 つはベクトルを導入するときに値の一部として必要とされ、@c
先頭の @code{#} は @code{\override} コマンドの中で常に値の前に@c
置くことが必要とされます。

@cindex BarLine, example of overriding (BarLine をオーバライドする例)
@cindex break-visibility property, example (break-visibility プロパティの例)

@lilypond[quote,ragged-right,verbatim]
\relative {
  \time 12/16
  \override Staff.BarLine.break-visibility = ##(#f #f #f)
  c''4 b8 c d16 c d8 |
  g,8 a16 b8 c d4 e16 |
  e8
}
@end lilypond

今度もすべての小節線が消えました。


@node The transparent property
@unnumberedsubsubsec @code{transparent} プロパティ

@cindex transparent property (transparent プロパティ)
@cindex transparency (透明性)

内部リファレンスの @code{grob-interface} ページにあるプロパティから
@code{transparent} プロパティはブール値であることがわかります。@c
これはグラフィカル オブジェクトを透明にする場合には @code{#t} に@c
セットします。@c
次の例では、小節線ではなく拍子記号を不可視にしてみましょう。@c
そうするには、まず、拍子記号のグラフィカル オブジェクト名を@c
見つける必要があります。@c
@code{TimeSignature} レイアウト オブジェクトのプロパティを見つけるために@c
内部リファレンスの @q{すべてのレイアウト オブジェクト} ページに@c
戻ってください。@c
@code{TimeSignature} は @code{Time_signature_engraver} によって作り出され、@c
さらに、@code{Time_signature_engraver} は @code{Staff} コンテキストに含まれ、@c
さらに、@code{Staff} コンテキストは @code{grob-interface} を@c
サポートしているということがわかります。@c
そのため、拍子記号を透明にするためのコマンドは以下のようになります:

@cindex TimeSignature, example of overriding (TimeSignature をオーバライドする例)
@cindex transparent property, example (transparent プロパティの例)

@lilypond[quote,ragged-right,verbatim]
\relative {
  \time 12/16
  \override Staff.TimeSignature.transparent = ##t
  c''4 b8 c d16 c d8 |
  g,8 a16 b8 c d4 e16 |
  e8
}
@end lilypond

@noindent
@code{transparent} プロパティに @code{#t} をセットする操作も頻繁に行うので、@c
短くしたコマンド @code{\hide} が用意されています:
@funindex \hide

@lilypond[quote,ragged-right,verbatim]
\relative {
  \time 12/16
  \hide Staff.TimeSignature
  c''4 b8 c d16 c d8 |
  g,8 a16 b8 c d4 e16 |
  e8
}
@end lilypond

@noindent
どちらの場合でも拍子記号は消えました。@c
しかしながら、このコマンドは拍子記号があるべき場所に隙間を残しています。@c
たぶん、これは学生がその部分を埋めるための練習としては望ましいでしょうが、@c
他の状況ではこの隙間は望ましくありません。@c
この隙間を取り除くには、拍子記号の @code{transparent} の代わりに@c
ステンシル (型、型紙) を @code{#f} にセットします:

@cindex TimeSignature, example of overriding (TimeSignature をオーバライドする例)
@cindex stencil property, example (stencil プロパティの例)

@lilypond[quote,ragged-right,verbatim]
\relative {
  \time 12/16
  \omit Staff.TimeSignature
  c''4 b8 c d16 c d8 |
  g,8 a16 b8 c d4 e16 |
  e8
}
@end lilypond

@noindent
違いは明白です: ステンシルを @code{#f} にセットする
(@code{\omit} を用いることもできます) と、オブジェクト自体が削除されます。@c
一方、オブジェクトを @code{transparent} (透明) にする
(@code{\hide} を用いることもできます)とそのオブジェクトは消えますが、@c
オブジェクトは不可視になっただけです。

@subheading 色 (color)

@node The color property
@unnumberedsubsubsec @code{color} プロパティ

最後に、小節線の色を白にすることによって小節線を不可視にしてみましょう。@c
(これには白い小節線が譜線と交差したところで@c
譜線を見えたり見えなくしてしまうかもしれないという問題があります。@c
以下のいくつかの例で、このことを予測することはできないと思うかもしれません。@c
そうなる理由と、それを制御する方法についての詳細は、@c
@rnotation{Painting objects white} でカバーされています。@c
しかしここでは色について学んでいるところなので、@c
オブジェクトを白で描くことの限界を受け入れるだけにしてください。)

@code{grob-interface} はカラー プロパティの値はリストであると指定しています。@c
しかしながら、そのリストが何であるべきなのかの説明はありません。@c
カラー プロパティで必要とされるリストは実際のところ内部ユニットの中にある@c
値のリストです。@c
しかし、内部ユニットの中にある値を知らなくても済むように、@c
カラーを指定するための手段がいくつか用意されています。@c
最初の方法は @rnotation{List of colors} にある最初の表でリスト アップされている
@q{標準} のカラーの 1 つを使用する方法です。@c
小節線を白にするには以下のように記述します:

@cindex BarLine, example of overriding (BarLine をオーバライドする例)
@cindex color property, example (color プロパティの例)

@lilypond[quote,ragged-right,verbatim]
\relative {
  \time 12/16
  \override Staff.BarLine.color = #white
  c''4 b8 c d16 c d8 |
  g,8 a16 b8 c d4 e16 |
  e8
}
@end lilypond

@noindent
今度も再び小節線は見えなくなりました。@c
@emph{white} の前にアポストロフィは付かないということに注意してください
-- これはシンボルではなく@emph{変数}です。@c
この変数は評価される時、小節線の色を白にセットするのに必要な内部的な値の@c
リストを提供します。@c
標準カラー リストにある他のカラーもまた変数です。@c
小節線の色をこのリストの中にある他の変数に変更することで、@c
これが機能することをあなた自身で納得できます。

@cindex color, X11 (X11 カラー)
@cindex X11 colors (X11 カラー)

@funindex x11-color

カラーを変えるための 2 つ目の方法は、@rnotation{List of colors} の
2 番目のリストの中にある X11 カラー名のリストを使用する方法です。@c
しかしながら、X11 カラー名は関数 @code{x11-color} によって実際の値に@c
マッピングされます。@c
@code{x11-color} は以下のように X11 カラー シンボルを内部値のリストに@c
変換します:

@cindex BarLine, example of overriding (BarLine をオーバライドする例)
@cindex color property, example (color プロパティの例)

@lilypond[quote,ragged-right,verbatim]
\relative {
  \time 12/16
  \override Staff.BarLine.color = #(x11-color 'white)
  c''4 b8 c d16 c d8 |
  g,8 a16 b8 c d4 e16 |
  e8
}
@end lilypond

@noindent
この場合、関数 @code{x11-color} はシンボルを引数として扱うので、@c
変数として評価されないようシンボルの前にアポストロフィを付ける必要があり、@c
関数呼び出し全体を括弧で囲む必要があるということに注意してください。

@cindex rgb colors (RGB カラー)
@cindex color, rgb (RGB カラー)

@funindex rgb-color

もう 1 つ関数があります。@c
RGB 値を内部カラーに変換する @code{rgb-color} 関数です。@c
この関数は赤、緑、青の輝度を表す 3 つの引数をとります。@c
これらの引数は 0 から 1 までの値をとります。@c
ですから、カラーを赤にセットする場合の値は @code{(rgb-color 1 0 0)} となり、@c
白の場合は @code{(rgb-color 1 1 1)} となります:

@cindex BarLine, example of overriding (BarLine をオーバライドする例)
@cindex color property, example (color プロパティの例)

@lilypond[quote,ragged-right,verbatim]
\relative {
  \time 12/16
  \override Staff.BarLine.color = #(rgb-color 1 1 1)
  c''4 b8 c d16 c d8 |
  g,8 a16 b8 c d4 e16 |
  e8
}
@end lilypond

最後に、X11 カラー セットの一部であるグレー スケールを用いる方法もあります。@c
グレー スケールの範囲は黒 @code{'grey0} から白 @code{'grey100} まで
1 段階ずつあります。@c
グレー スケールの使用方法を示すために、@c
例の中にあるすべてのレイアウト オブジェクトのカラーをさまざまな濃度の@c
グレーにセットしてみましょう:

@cindex StaffSymbol, example of overriding (StaffSymbol をオーバライドする例)
@cindex TimeSignature, example of overriding (TimeSignature をオーバライドする例)
@cindex Clef, example of overriding (Clef をオーバライドする例)
@cindex NoteHead, example of overriding (NoteHead をオーバライドする例)
@cindex Stem, example of overriding (Stem をオーバライドする例)
@cindex BarLine, example of overriding (BarLine をオーバライドする例)
@cindex color property, example (color プロパティの例)
@cindex x11-color, example of using (x11-color の使用例)

@lilypond[quote,ragged-right,verbatim]
\relative {
  \time 12/16
  \override Staff.StaffSymbol.color = #(x11-color 'grey30)
  \override Staff.TimeSignature.color = #(x11-color 'grey60)
  \override Staff.Clef.color = #(x11-color 'grey60)
  \override Voice.NoteHead.color = #(x11-color 'grey85)
  \override Voice.Stem.color = #(x11-color 'grey85)
  \override Staff.BarLine.color = #(x11-color 'grey10)
  c''4 b8 c d16 c d8 |
  g,8 a16 b8 c d4 e16 |
  e8
}
@end lilypond

@noindent
各レイアウト オブジェクトに関連付けされているコンテキストに注意してください。@c
これらのコンテキストを正しく取得することが重要であり、@c
そうしなければコマンドは機能しません！@c
コンテキストの中には特定のエングラーバが置かれているということを@c
忘れないでください。@c
エングラーバに対するデフォルト コンテキストを見つけ出すには、@c
内部リファレンスのレイアウト オブジェクトからスタートして、@c
そこからそれを作り出すエングラーバのページに行きます。@c
エングラーバのページには、@c
通常はどのコンテキストにそのエングラーバが含まれているのかが記述されています。


@node Size of objects
@subsection オブジェクトのサイズ

@cindex changing size of objects (オブジェクトのサイズを変更する)
@cindex size of objects (オブジェクトのサイズ)
@cindex objects, size of (オブジェクトのサイズ)
@cindex objects, changing size of (オブジェクトのサイズを変更する)

以前の例を見直すことから始めてみましょう
(@ref{Nesting music expressions} を参照してください)。@c
そこでは @rglos{ossia} として新たに一時的な譜を導入する方法が示されています。

@cindex alignAboveContext property, example (alignAboveContext プロパティの例)
@cindex @code{\with}, example (@code{\with} の例)

@lilypond[quote,ragged-right,verbatim]
\new Staff ="main" {
  \relative {
    r4 g'8 g c4 c8 d |
    e4 r8
    <<
      { f8 c c }
      \new Staff \with {
        alignAboveContext = "main" }
      { f8 f c }
    >>
    r4 |
  }
}
@end lilypond

通常、オッシアは音部記号と拍子記号無しで記述され、@c
メインの譜よりもわずかに小さく譜刻されます。@c
今度は、すでに音部記号と拍子記号を削除する方法を知っています
-- 以下のようにそれぞれのステンシルを @code{#f} にセットするだけです:

@cindex alignAboveContext property, example (alignAboveContext プロパティの例)
@cindex @code{\with}, example (@code{\with} の例)
@funindex \omit
@cindex Clef, example of overriding (Clef をオーバライドする例)
@cindex TimeSignature, example of overriding (TimeSignature をオーバライドする例)

@lilypond[quote,ragged-right,verbatim]
\new Staff ="main" {
  \relative {
    r4 g'8 g c4 c8 d |
    e4 r8
    <<
      { f8 c c }
      \new Staff \with {
        alignAboveContext = "main"
      }
      {
        \omit Staff.Clef
        \omit Staff.TimeSignature
        { f8 f c }
      }
    >>
    r4 |
  }
}
@end lilypond

@noindent
ここで、@code{\with} 節の後にある追加の括弧のペアが、@c
その括弧に囲まれているオーバライドと音楽がオッシア譜に適用されることを@c
保証するために、必要となります。

しかし、@code{\with} を用いた譜コンテキストの変更と @code{\override}
を用いた音部記号と拍子記号のステンシルの変更 (あるいはこのケースでは
@code{\omit} を用いています) との違いは何なのでしょうか？@c
主な違いは、@code{\with} 節の中で行われた変更はそのコンテキストが@c
作成されるときに行われ、@c
そのコンテキストでは @strong{デフォルト} 値として残ります。@c
一方、音楽の中に埋め込まれた @code{\set} コマンドや
@code{\override} コマンドは動的です
-- それらは音楽のある特定のポイントに同期して変更を行います。@c
変更が @code{\unset} や @code{\revert} を使ってセットを解除されたり@c
元に戻された場合、デフォルト値
-- これは @code{\with} 節でセットされていた場合はその値、@c
そうでない場合は通常のデフォルト値 -- に戻ります。

いくつかのコンテキスト プロパティは @code{\with} 節でのみ変更可能です。@c
これらは、コンテキストが作成された後では、変更されることのないプロパティです。@c
@code{alignAboveContext} とそのパートナー @code{alignBelowContext} が@c
そのようなプロパティです -- いったん譜が作成されると、@c
譜のアラインメントは決定され、@c
それを後で変更しようとすることには意味がありません。

レイアウト オブジェクトのデフォルト値は @code{\with} 節で@c
セットすることもできます。@c
通常の @code{\override} コマンドをコンテキスト名を省いて@c
使用するだけです。@c
コンテキスト名を省略するのは、そのコンテキストは明らかに
@code{\with} 節が変更しようとしているコンテキストだからです。@c
実際、@code{\with} 節の中でコンテキストを指定するとエラーが発生します。

それでは上記の例を以下のように書き換えます:

@cindex alignAboveContext property, example (alignAboveContext プロパティの例)
@cindex @code{\with}, example (@code{\with} の例)
@cindex Clef, example of overriding (Clef をオーバライドする例)
@cindex TimeSignature, example of overriding (TimeSignature をオーバライドする例)

@lilypond[quote,ragged-right,verbatim]
\new Staff ="main" {
  \relative {
    r4 g'8 g c4 c8 d |
    e4 r8
    <<
      { f8 c c }
      \new Staff \with {
        alignAboveContext = "main"
        % この譜には音部記号を譜刻しません
        \override Clef.stencil = ##f
        % この譜には拍子記号を譜刻しません
        \override TimeSignature.stencil = ##f
      }
      { f8 f c }
    >>
    r4 |
  }
}
@end lilypond

@code{transparent} プロパティを設定したり @code{stencil} を消すために@c
短縮形 @code{\hide} と @code{\omit} を使うことができ、結果として@c
以下のようになります:

@lilypond[quote,ragged-right,verbatim]
\new Staff ="main" {
  \relative {
    r4 g'8 g c4 c8 d |
    e4 r8
    <<
      { f8 c c }
      \new Staff \with {
        alignAboveContext = "main"
        % この譜には音部記号を譜刻しません
        \omit Clef
        % この譜には拍子記号を譜刻しません
        \omit TimeSignature
      }
      { f8 f c }
    >>
    r4 |
  }
}
@end lilypond

最後に、レイアウト オブジェクトのサイズを変更してみます。

いくつかのレイアウト オブジェクトはある書体から選択された図柄として@c
作成されます。@c
これには符頭、臨時記号、マークアップ、音部記号、拍子記号、強弱記号、@c
歌詞が含まれます。@c
それらのサイズは、これから見ていくように、@code{font-size} プロパティを@c
変更することによって変更されます。@c
スラーやタイのような他のレイアウト オブジェクト
-- 一般には、スパナ オブジェクト (spanner objects)
-- は個々に描かれるため、@c
@code{font-size} プロパティとは関係がありません。@c
一般に、それらのオブジェクトはそれらを取り付けられるオブジェクトからサイズを@c
決定する (訳者: 例えば、スラーはそのスラーが付着する音符から@c
そのスラーのサイズを決定する) ので、@c
通常はサイズを手動で変更する必要はありません。@c
さらに、符幹や小節線の長さ、連桁や他の線の太さ、譜線の間隔などといった@c
他のプロパティはすべて特別な方法で変更する必要があります。

オッシアの例に戻って、まず @code{font-size} を変更してみましょう。@c
これを行うには 2 通りの方法があります。@c
以下のようなコマンドで @code{NoteHead} のような各オブジェクト タイプの@c
フォント サイズを変更する:

@example
\override NoteHead.font-size = #-2
@end example

あるいは、@code{\set} を使って特別なプロパティ @code{fontSize} を設定するか、@c
それを @code{\with} 節に含める
(ただし、@code{\set} は含めません) ことによって@c
すべてのフォントのサイズを変更します:

@example
\set fontSize = #-2
@end example

これらの命令文は両方ともフォント サイズを前の値から 2 段階減らします。@c
各段階でサイズはおよそ 12% 増減します。

それではオッシアの例でフォント サイズを変更してみましょう:

@cindex alignAboveContext property, example (alignAboveContext プロパティの例)
@cindex @code{\with}, example (@code{\with} の例)
@cindex Clef, example of overriding (Clef をオーバライドする例)
@cindex TimeSignature, example of overriding (TimeSignature をオーバライドする例)
@cindex fontSize property, example (fontSize プロパティの例)

@lilypond[quote,ragged-right,verbatim]
\new Staff ="main" {
  \relative {
    r4 g'8 g c4 c8 d |
    e4 r8
    <<
      { f8 c c }
      \new Staff \with {
        alignAboveContext = "main"
        \omit Clef
        \omit TimeSignature
        % すべてのフォント サイズを約 24% 減らします
        fontSize = #-2
      }
      { f8 f c }
    >>
    r4 |
  }
}
@end lilypond

これでもまだ完璧ではありません。@c
符頭とフラグは小さくなりましたが、符幹はそれに対して長すぎ、@c
譜線は離れすぎています。@c
これらをフォント サイズの減少に比例してスケール ダウンさせる必要があります。@c
次のサブ セクションでそれを行う方法について議論します。

@node Length and thickness of objects
@subsection オブジェクトの長さと太さ

@cindex distances (距離)
@cindex thickness (太さ)
@cindex length (長さ)
@cindex magstep
@cindex size, changing (サイズを変更する)
@cindex stem length, changing (符幹の長さを変更する)
@cindex staff line spacing, changing (譜線の間隔を変更する)

LilyPond では距離と長さは一般に譜スペース -- 譜の中の隣り合う線の間隔 --
で測ります (特別な場合では、譜スペースの半分で測ることもあります)。@c
一方、たいていの @code{thickness} プロパティは @code{line-thickness} と@c
呼ばれる内部プロパティを単位として測ります。@c
例えば、デフォルトでは、ヘアピン (訳者: 強弱記号) の線の太さは
1 単位の @code{line-thickness} であり、@c
音符の符幹の @code{thickness} は 1.3 です。@c
けれども、それとは単位の異なる太さプロパティがあるということにも@c
注意してください。@c
例えば、連桁の太さプロパティは譜スペースで測ります。

それでは、どうやって長さをフォント サイズに比例させるのでしょうか？@c
これは、まさにこの目的のために提供されている @code{magstep} と呼ばれる@c
特別な関数の助けを借りることによって達成できます。@c
この関数は引数を 1 つ -- フォント サイズの変化 (前の例では #-2) --
をとり、他のオブジェクトの縮小に比例したスケーリング ファクタを返します。@c
以下のように使用します:

@cindex alignAboveContext property, example (alignAboveContext プロパティの例)
@cindex @code{\with}, example (@code{\with} の例)
@cindex Clef, example of overriding (Clef をオーバライドする例)
@cindex TimeSignature, example of overriding (TimeSignature をオーバライドする例)
@cindex fontSize property, example (fontSize プロパティの例)
@cindex StaffSymbol, example of overriding (StaffSymbol をオーバライドする例)
@cindex magstep function, example of using (magstep 関数の使用例)
@cindex staff-space property, example (staff-space プロパティの例)
@cindex stencil property, example (stencil プロパティの例)

@lilypond[quote,ragged-right,verbatim]
\new Staff ="main" {
  \relative {
    r4 g'8 g c4 c8 d |
    e4 r8
    <<
      { f8 c c }
      \new Staff \with {
        alignAboveContext = "main"
        \omit Clef
        \omit TimeSignature
        fontSize = #-2
        % 符幹の長さと譜線の間隔を減らします
        \override StaffSymbol.staff-space = #(magstep -2)
      }
      { f8 f c }
    >>
    r4 |
  }
}
@end lilypond

@noindent
符幹の長さと他の多くの長さに関係するプロパティは常に
@code{staff-space} プロパティの値と比例関係になるよう算出されるため、@c
それらの長さも自動的にスケール ダウンされます。@c
これはオッシアの垂直方向のスケールだけに効果を及ぼすということに@c
注意してください -- 水平方向のスケールは、メインの音楽と同期するよう、@c
メインの音楽のレイアウトによって決定されるため、水平方向のスケールは
@code{staff-space} の変更によっていかなる影響も受けません。@c
もちろん、メインの音楽のすべてのスケールがこの方法で変更された場合、@c
水平方向のスペースも影響を受けます。@c
このことについては、後のレイアウト セクションで議論します。

そして、これでオッシアの作成は完了です。@c
他のすべてのオブジェクトのサイズと長さが類似の方法で変更されるかもしれません。

上記の例のようなスケールのちょっとした変更に対して、小節線、連桁、ヘアピン、@c
スラーなどのさまざまな描画線の太さは通常はグローバルな調節を必要としません。@c
ある特定のレイアウト オブジェクトの太さを調節する必要がある場合、@c
それを達成する最良の方法はそのオブジェクトの @code{thickness} プロパティを@c
オーバライドすることです。@c
スラーの太さを変更する例は @ref{Properties of layout objects} で@c
示されています。@c
すべての描画オブジェクト (つまり、フォントから作り出される@c
オブジェクトではないもの) の太さが同様の方法で変更されるかもしれません。


@need 1500
@node Placement of objects
@section オブジェクトの配置


@node Automatic behavior
@subsection 自動配置

@cindex within-staff objects (譜内部オブジェクト)
@cindex outside-staff objects (譜内部オブジェクト)
@cindex objects, within-staff (譜内部オブジェクト)
@cindex objects, outside-staff (譜外部オブジェクト)

音楽記譜法には譜に属するオブジェクトがいくつかあり、@c
他のオブジェクトは譜の外側に置かれるべきです。@c
それらはそれぞれ譜内部オブジェクトと譜外部オブジェクトと呼ばれます。

譜内部オブジェクトは譜上に置かれます
-- 符頭、符幹、臨時記号などです。@c
通常、それらの位置は音楽自体によって決定されます
-- 譜内部オブジェクトは譜のある特定の線と同じ垂直位置に置かれたり、@c
そこに置かれるべき他のオブジェクトにくっつけられたりします。@c
近接する和音の中にある符頭、符幹、臨時記号の衝突は普通は自動的に回避されます。@c
これから見ていくように、この自動配置を変更することができるコマンドと@c
オーバライドがあります。

譜の外部にあるオブジェクトには、リハーサル記号、テキスト、@c
強弱記号などがあります。@c
LilyPond が持つ譜外部オブジェクトの垂直位置のルールは、@c
譜外部オブジェクトをできるだけ譜の近くに、しかし他のオブジェクトと@c
衝突しない程度の近さに置くというものです。@c
以下で示すように、LilyPond はオブジェクトを配置する順番を決定するために
@code{outside-staff-priority} プロパティを使用します。

最初に、LilyPond はすべての譜内部オブジェクトを配置します。@c
それから、@code{outside-staff-priority} に従って譜外部オブジェクトを@c
並べます。@c
譜外部オブジェクトは最小の @code{outside-staff-priority} を@c
持つオブジェクトから順番に 1 つずつ並べられ、すでに配置されたオブジェクトと@c
衝突しないように配置されます。@c
つまり、2 つの譜外部オブジェクトが同じスペースを巡って競合する場合、@c
より小さな @code{outside-staff-priority} を持つオブジェクトが@c
譜の近くに配置されます。@c
2 つのオブジェクトが同じ @code{outside-staff-priority} を持つ場合、@c
先に発生するオブジェクトが譜の近くに配置されます。

以下の例では、すべてのマークアップ テキストが同じ優先度を持っています
(なぜなら、優先度が明示的にセットされていないからです)。@c
@q{Text3} が自動的に譜の近く、@q{Text2} の@c
すぐ下に納まるよう配置されていることに注意してください。

@cindex markup example (マークアップの例)

@lilypond[quote,fragment,ragged-right,verbatim]
c''2^"Text1"
c''2^"Text2" |
c''2^"Text3"
c''2^"Text4" |
@end lilypond

デフォルトでは、譜も互いにできるだけ近くなるよう配置されます
(最小間隔に従います)。@c
音符が隣接する譜に向かって長く突き出てている場合、譜を離さないと@c
記譜したものが重なり合ってしまう場合にのみ譜は離されます。@c
以下の例は譜の調整によって音符が @q{ぴったりと納まる} 様子を示しています:

@lilypond[quote,ragged-right,verbatim]
<<
  \new Staff {
    \relative { c'4 a, }
  }
  \new Staff {
    \relative { c''''4 a, }
  }
>>
@end lilypond


@node Within-staff objects
@subsection 譜内部オブジェクト

これまでにコマンド @code{\voiceXXX} がスラー、タイ、運指法記号、@c
符幹の向きに依存する他のすべてに対してどのように影響を与えるかを見てきました
-- @ref{Explicitly instantiating voices} を参照してください。
これらのコマンドは、多声部音楽を記述しているときに上下する旋律を@c
見分けられるようにすることを可能にするために不可欠なものです。@c
しかしながら、この自動機能をオーバライドする必要がある場合もあります。@c
このオーバライドは音楽全体に対しても、個々の音符に対してもできます。@c
この自動機能を制御しているプロパティは各レイアウト オブジェクトの
@code{direction} プロパティです。@c
まず、これは何をするのかを説明し、それから、作成済みのコマンドを@c
いくつか紹介します。@c
それらのコマンドを使うと、一般的な変更のための明示的なオーバライドを@c
コードしなくて済みます。

スラーやタイのようなレイアウト オブジェクトはカーブを描き、曲がり、@c
上下します。@c
符幹やフラグのような他のオブジェクトも上下の向きによって位置が左右します。@c
@code{direction} がセットされているときは、これは自動的に制御されます。


@node The direction property
@unnumberedsubsubsec @code{direction} プロパティ

@cindex down (下)
@cindex up (上)
@cindex center (中央)
@cindex neutral (ニュートラル)

以下の例は、最初の小節でスラーのデフォルトの振る舞いを示しています。@c
高い位置にある音符のスラーは音符の上にあり、@c
低い位置にある音符のスターは音符の下にあります。@c
次の小節では両方のスラーをすべて強制的に下向きにし、
さらに次の小節では両方のスラーをすべて強制的に上向きにし、
最後の小節ではスラーの向きをデフォルトに戻します。

@cindex Slur, example of overriding (Slur をオーバライドする例)
@cindex direction property, example (direction プロパティの例)

@lilypond[quote,fragment,verbatim]
a'4( g') c''( a') |
\override Slur.direction = #DOWN
a'4( g') c''( a') |
\override Slur.direction = #UP
a'4( g') c''( a') |
\revert Slur.direction
a'4( g') c''( a') |
@end lilypond

ここで定数 @code{DOWN} と @code{UP} を使っています。@c
これらはそれぞれ値 @w{@code{-1}} と @code{+1} を持ち、定数の代わりに@c
それらの数値を使うこともできまはす。@c
さらに値 @code{0} を使う場合もあります。@c
この値はスラーでは @code{UP} を意味するものとして扱われますが、@c
いくつかのオブジェクトでは @q{center} という意味になります。@c
値 @code{0} を持つ定数に @code{CENTER} があります。

しかしながら、これらの明示的なオーバライドは普通は使われません。@c
もっと簡単で定義済みのコマンドが利用可能だからです。@c
ここに一般的なコマンドの表を挙げます。@c
それぞれのコマンドの意味が明白でない場合は、そのコマンドの意味を述べています。

@multitable @columnfractions .2 .2 .25 .35
@headitem 下/左
  @tab 上/右
  @tab 元に戻す
  @tab 効果
@item @code{\arpeggioArrowDown}
  @tab @code{\arpeggioArrowUp}
  @tab @code{\arpeggioNormal}
  @tab 矢印が下に付く、上に付く、付かない
@item @code{\dotsDown}
  @tab @code{\dotsUp}
  @tab @code{\dotsNeutral}
  @tab 譜線を避けるための移動方向
@item @code{\dynamicDown}
  @tab @code{\dynamicUp}
  @tab @code{\dynamicNeutral}
  @tab
@item @code{\phrasingSlurDown}
  @tab @code{\phrasingSlurUp}
  @tab @code{\phrasingSlurNeutral}
  @tab Note: スラー コマンドとは別になります
@item @code{\slurDown}
  @tab @code{\slurUp}
  @tab @code{\slurNeutral}
  @tab
@item @code{\stemDown}
  @tab @code{\stemUp}
  @tab @code{\stemNeutral}
  @tab
@item @code{\textSpannerDown}
  @tab @code{\textSpannerUp}
  @tab @code{\textSpannerNeutral}
  @tab スパナとして挿入されるテキストが譜の下/上にくる
@item @code{\tieDown}
  @tab @code{\tieUp}
  @tab @code{\tieNeutral}
  @tab
@item @code{\tupletDown}
  @tab @code{\tupletUp}
  @tab @code{\tupletNeutral}
  @tab 連符記号が音符の下/上にくる
@end multitable

これらのコマンドで中立/通常の位置に戻すコマンドは @code{\revert} を@c
用いることで実装されていて、これらは前に @code{\once} が付いて @strong{いない}
かもしれません。@c
@code{\override} を用いて実装されているコマンドの効果を単一のタイミング@c
に限定したいのであれば、明示的なオーバライドの場合と同様に、@c
コマンドの前に @code{\once} を配置します。

あるいは、単に 1 つのレイアウト オブジェクトを上向きか下向きにしたいなら、@c
方向指示子の @code{^} か @code{_} を使うことができます:

@lilypond[quote,fragment,verbatim]
a'4( g') c''( a') |
a'4^( g') c''_( a') |
@end lilypond

@node Fingering
@unnumberedsubsubsec 運指

@cindex fingering, placement (運指法記号の配置)
@cindex fingering, chords (和音の運指法記号)

単一の音符に対する運指法記号の配置も @code{direction} プロパティによって@c
制御できますが、@code{direction} を変更しても和音の運指法記号は影響を@c
受けません。@c
これから見ていくように、和音の中の個々の音符の運指法記号を制御するための@c
特別なコマンドがあります。@c
このコマンドを使うことで運指法記号を各音符の上、下、左、右に@c
配置することができます。

まず、単一の音符の運指法記号に対する @code{direction} を効果を示します。@c
最初の小節はデフォルト状態で、その後で @code{DOWN} と @code{UP} を@c
指定したときの効果を示します:

@cindex Fingering, example of overriding (Fingering をオーバライドする例)
@cindex direction property, example (direction プロパティの例)

@lilypond[quote,verbatim]
\relative {
  c''4-5 a-3 f-1 c'-5 |
  \override Fingering.direction = #DOWN
  c4-5 a-3 f-1 c'-5 |
  \override Fingering.direction = #UP
  c4-5 a-3 f-1 c'-5 |
}
@end lilypond

しかしながら、@code{direction} プロパティをオーバライドすることは、@c
手動で運指法記号を音符の上または下に配置するもっとも簡単な方法ではありません。@c
運指法番号の前に @code{-} の代わりに @code{_} または @code{^} を使う方が@c
普通は適切です。@c
ここで、上記の例にこの方法を用いた例を挙げます:

@cindex fingering example (運指法記号の例)

@lilypond[quote,verbatim]
\relative {
  c''4-5 a-3 f-1 c'-5 |
  c4_5 a_3 f_1 c'_5 |
  c4^5 a^3 f^1 c'^5 |
}
@end lilypond

@code{direction} プロパティは和音では無視されますが、@c
方向を示す接頭辞 @code{_} と @code{^} は機能します。@c
以下で示すように、デフォルトでは、運指法記号は和音の音符の@c
上と下の両方に自動的に配置されます:

@cindex fingering example (運指法記号の例)

@lilypond[quote,verbatim]
\relative {
  <c''-5 g-3>4
  <c-5 g-3 e-2>4
  <c-5 g-3 e-2 c-1>4
}
@end lilypond

@noindent
しかし、以下で示すように、運指法番号のすべてまたはいずれかを手動で強制的に@c
和音の上または下に配置するために、これはオーバライドされるかもしれません:

@cindex fingering example (運指法記号の例)

@lilypond[quote,verbatim]
\relative {
  <c''-5 g-3 e-2 c-1>4
  <c^5 g_3 e_2 c_1>4
  <c^5 g^3 e^2 c_1>4
}
@end lilypond

@code{\set fingeringOrientations} コマンドを使うことによって和音の中に@c
ある個々の音符の運指法記号の配置をより細かく制御することさえできます。@c
このコマンドのフォーマットは以下のようなものです:

@example
\set fingeringOrientations = #'([up] [left/right] [down])
@end example

@noindent
@code{fingeringOrientations} は @code{Voice} コンテキストのプロパティであり、@c
@code{New_fingering_engraver} によって作成、使用されるため、@c
@code{\set} が使用されます。

このプロパティには 1 つから 3 つまでの値のリストがセットされるかもしれません。@c
このプロパティは運指法記号を上 (リストに @code{up} がある場合)、@c
下 (リストに @code{down} がある場合)、@c
左 (リストに @code{left} がある場合。リストに @code{right} がある場合は右)
に配置します。@c
逆に配置位置がリストされていない場合、その位置に運指法記号は配置されません。@c
LilyPond はこれらの制約を受け取り、
後に続く和音の音符への運指法記号をうまく配置します。@c
@code{left} と @code{right} は相互排他的であるということに注意してください --
運指法記号は左右のどちらかにしか配置されないか、どちらにも配置されません。

@warning{このコマンドを使って単一の音符への運指法記号の配置を@c
コントロールするには、その音符を山括弧で囲んで単一音符の和音として@c
記述する必要があります。}

いくつか例を挙げます:

@cindex fingering example (運指法記号の例)
@cindex @code{\set}, example of using (@code{\set} の使用例)
@cindex fingeringOrientations property, example (fingeringOrientations プロパティの例)

@lilypond[quote,ragged-right,verbatim]
\relative {
  \set fingeringOrientations = #'(left)
  <f'-2>4
  <c-1 e-2 g-3 b-5>4
  \set fingeringOrientations = #'(left)
  <f-2>4
  <c-1 e-2 g-3 b-5>4 |
  \set fingeringOrientations = #'(up left down)
  <f-2>4
  <c-1 e-2 g-3 b-5>4
  \set fingeringOrientations = #'(up left)
  <f-2>4
  <c-1 e-2 g-3 b-5>4 |
  \set fingeringOrientations = #'(right)
  <f-2>4
  <c-1 e-2 g-3 b-5>4
}
@end lilypond

@noindent
運指法記号が少し込み合っているように見える場合は、@c
@code{font-size} でサイズを下げることができます。@c
デフォルト値は内部リファレンスの @code{Fingering} オブジェクトのページから
@w{@code{-5}} であることがわかるので、@w{@code{-7}} にセットしてみましょう:

@lilypond[quote,ragged-right,verbatim]
\relative {
  \override Fingering.font-size = #-7
  \set fingeringOrientations = #'(left)
  <f'-2>4
  <c-1 e-2 g-3 b-5>4
  \set fingeringOrientations = #'(left)
  <f-2>4
  <c-1 e-2 g-3 b-5>4 |
  \set fingeringOrientations = #'(up left down)
  <f-2>4
  <c-1 e-2 g-3 b-5>4
  \set fingeringOrientations = #'(up left)
  <f-2>4
  <c-1 e-2 g-3 b-5>4 |
  \set fingeringOrientations = #'(right)
  <f-2>4
  <c-1 e-2 g-3 b-5>4
}
@end lilypond


@node Outside-staff objects
@subsection 譜外部オブジェクト

譜外部オブジェクトは自動的に衝突を回避するよう配置されます。@c
配置が最適でない場合に自動配置をオーバライドする方法がいくつかあります。


@node The outside-staff-priority property
@unnumberedsubsubsec @code{outside-staff-priority} プロパティ

小さな値の @code{outside-staff-priority} プロパティを持つオブジェクトは@c
譜の近くに配置され、他の譜外部オブジェクトは衝突を避けるのに必要な分だけ@c
離されます。@c
@code{outside-staff-priority} は @code{grob-interface} の中で@c
定義されているため、すべてのレイアウト  オブジェクトのプロパティです。@c
デフォルトでは、すべての譜内部オブジェクトの @code{outside-staff-priority} は
@code{#f} にセットされていて、譜外部オブジェクトが作成されたときに@c
その譜外部オブジェクトの @code{outside-staff-priority} に適当な数値が@c
セットされます。@c
以下の表はいくつかの一般的な譜外部オブジェクトのデフォルトの
@code{outside-staff-priority} 値を示しています。

@multitable @columnfractions .3 .15 .45
@headitem レイアウト オブジェクト
  @tab 優先度
  @tab 以下のオブジェクトの配置を制御する:
@item @code{RehearsalMark}
  @tab @code{1500}
  @tab リハーサル記号
@item @code{MetronomeMark}
  @tab @code{1000}
  @tab メトロノーム記号
@item @code{SostenutoPedalLineSpanner}
  @tab @code{1000}
  @tab ペダル記号
@item @code{SustainPedalLineSpanner}
  @tab @code{1000}
  @tab
@item @code{UnaCordaPedalLineSpanner}
  @tab @code{1000}
  @tab
@item @code{MeasureCounter}
  @tab @code{750}
  @tab 小節番号
@item @code{VoltaBracketSpanner}
  @tab @code{600}
  @tab Volta (番号付きのリピート) の囲み
@item @code{InstrumentSwitch}
  @tab @code{500}
  @tab 楽器を変更するテキスト
@item @code{TextScript}
  @tab @code{450}
  @tab マークアップ テキスト
@item @code{MultiMeasureRestText}
  @tab @code{450}
  @tab 複数小節にわたる休符上のテキスト
@item @code{CombineTextScript}
  @tab @code{450}
  @tab パート結合のテキスト
@item @code{OttavaBracket}
  @tab @code{400}
  @tab オッターバ (オクターブを上下させる記号) の囲み
@item @code{TextSpanner}
  @tab @code{350}
  @tab テキスト スパナ
@item @code{DynamicLineSpanner}
  @tab @code{250}
  @tab すべての強弱記号
@item @code{BarNumber}
  @tab @code{100}
  @tab 小節番号
@item @code{TrillSpanner}
  @tab @code{50}
  @tab トリル記号
@item @code{AccidentalSuggestion}
  @tab @code{0}
  @tab 注釈的な臨時記号 (音符の上に付く臨時記号、ムジカ・フィクタ)
@end multitable

これらのうちのいくつかのデフォルトでの配置を示している例を挙げます。

@cindex text spanner (テキスト スパナ)
@cindex ottava bracket (オッターバ囲み)

@funindex \startTextSpan
@funindex \stopTextSpan

@cindex TextSpanner, example of overriding (TextSpanner をオーバライドする例)
@cindex bound-details property, example (bound-details プロパティの例)

@lilypond[quote,fragment,ragged-right,verbatim]
% 以降のテキスト スパナの詳細を設定します
\override TextSpanner.bound-details.left.text
    = \markup { \small \bold Slower }
% 強弱記号を譜の上に配置します
\dynamicUp
% オッターバ囲みの開始
\ottava #1
c''4 \startTextSpan
% 強弱テキストとヘアピンを付け加えます
c''4\pp\<
c''4
% テキスト スクリプトを付け加えます
c''4^Text |
c''4 c''
% 強弱テキストを付け加え、強弱ヘアピンを終わらせます
c''4\ff c'' \stopTextSpan |
% オッターバ囲みを終わらせます
\ottava #0
c'4 c' c' c' |
@end lilypond

この例はテキスト スパナ -- 音楽の上に置かれる延長線付きのテキスト -- の@c
作成方法についても示しています。@c
スパナは @code{\startTextSpan} コマンドから
@code{\stopTextSpan} コマンドまで延び、テキストのフォーマットは
@code{\override TextSpanner} コマンドによって定義されます。@c
詳細は @rnotationnamed{Text spanners, テキスト スパナ} を参照してください。

この例はさらにオッターバ囲みを作成する方法についても示しています。

@cindex tweaking bar number placement (小節番号の配置を調節する)
@cindex bar numbers, tweaking placement (小節番号の配置を調節する)
@cindex tweaking metronome mark placement (メトロノーム記号の配置を調節する)
@cindex metronome mark, tweaking placement (メトロノーム記号の配置を調節する)
@cindex tweaking rehearsal mark placement (リハーサル記号の配置を調節する)
@cindex rehearsal marks, tweaking placement (リハーサル記号の配置を調節する)

@code{outside-staff-priority} のデフォルト値による配置が@c
あなたの望みに合わない場合、いずれかのオブジェクトの優先度を@c
オーバライドすることになるかもしれません。@c
上記の例で、オッターバ囲みをテキスト スパナの下に配置したいとします。@c
すべきことは、@code{OttavaBracket} は @code{Staff} コンテキストの中に@c
作成されるということを思い出し、@code{OttavaBracket} の優先度を@c
内部リファレンスか上記の表で調べて、それを @code{TextSpanner} の値よりも@c
小さくすることです:

@cindex TextSpanner, example of overriding (TextSpanner をオーバライドする例)
@cindex bound-details property, example (bound-details プロパティの例)

@lilypond[quote,fragment,ragged-right,verbatim]
% 以降のテキスト スパナの詳細を設定します
\override TextSpanner.bound-details.left.text
    = \markup { \small \bold Slower }
% 強弱記号を譜の上に配置します
\dynamicUp
% 以降のオッターバ囲みをテキスト スパナの下に配置します
\once \override Staff.OttavaBracket.outside-staff-priority = #340
% オッターバ囲みの開始
\ottava #1
c''4 \startTextSpan
% 強弱テキストを付け加えます
c''4\pp
% 強弱の線スパナを付け加えます
c''4\<
% テキスト スクリプトを付け加えます
c''4^Text |
c''4 c''
% 強弱テキストを付け加えます
c''4\ff c'' \stopTextSpan |
% オッターバ囲みを終わらせます
\ottava #0
c'4 c' c' c' |
@end lilypond

これらのオブジェクトのいくつか
-- 特に、小節番号、メトロノーム記号、それにリハーサル記号 --
はデフォルトでは @code{Score} コンテキストの中にあるため、@c
それらのプロパティをオーバライドする場合は適切なコンテキストを@c
指定する必要があることに注意してください。

@cindex slurs and outside-staff-priority (スラーと outside-staff-priority)
@cindex slurs and articulations (スラーとアーティキュレーション)
@cindex articulations and slurs (アーティキュレーションとスラー)

スラーはデフォルトでは譜内部オブジェクトに分類されています。@c
しかしながら、譜の上部に配置された音符に付くスラーは@c
しばしば譜の上に表示されます。@c
このことは、スラーがまず最初に配置されるため、アーティキュレーションなどの@c
譜外部オブジェクトをあまりにも高い位置に押し上げる可能性があります。@c
アーティキュレーションの @code{avoid-slur} プロパティに
@code{'inside} をセットすることでアーティキュレーションを@c
スラーよりも内側に配置することができます。@c
しかし、@code{avoid-slur} プロパティはアーティキュレーションの
@code{outside-staff-priority} が @code{#f} にセットされている場合にのみ@c
効果を持ちます。@c
代替手段として、スラーの @code{outside-staff-priority} に数値を@c
セットすることによって、スラーを他の譜外部オブジェクトとともに
@code{outside-staff-priority} 値に従って配置することができます。@c
ここで、2 つの方法の効果を示す例を挙げます:

@lilypond[quote,verbatim]
\relative c'' {
  c4( c^\markup { \tiny \sharp } d4.) c8 |
  c4(
    \once \override TextScript.avoid-slur = #'inside
    \once \override TextScript.outside-staff-priority = ##f
    c4^\markup { \tiny \sharp } d4.) c8 |
  \once \override Slur.outside-staff-priority = #500
    c4( c^\markup { \tiny \sharp } d4.) c8 |
}
@end lilypond

@code{outside-staff-priority} は、個々のオブジェクトの垂直方向の配置を@c
制御するために使用することもできます。@c
しかしながら、その結果は常に望み通りになるわけではありません。@c
@ref{Automatic behavior} にある例で @qq{Text3} を @qq{Text4} の上に@c
配置したいとします。@c
すべきことは @code{TextScript} の優先度を内部リファレンスか上記の表で調べて、@c
@qq{Text3} の優先度を大きくすることです:

@cindex TextScript, example of overriding (TextScript をオーバライドする例)
@cindex outside-staff-priority property, example (outside-staff-priority プロパティの例)

@lilypond[quote,fragment,ragged-right,verbatim]
c''2^"Text1"
c''2^"Text2" |
\once \override TextScript.outside-staff-priority = #500
c''2^"Text3"
c''2^"Text4" |
@end lilypond

これはたしかに @qq{Text3} を @qq{Text4} の上に配置しています。@c
しかし、@qq{Text3}を @qq{Text2} の上に配置して、@c
@qq{Text4} を押し下げてもいます。@c
おそらく、これはそれほど望ましい結果ではないでしょう。@c
本当に望んでいることは、すべての注釈を@c
譜の上に譜から同じ距離だけ離して配置することです。@c
そうするには明らかに、テキストのためにもっと広いスペースを確保するために、@c
音符を水平方向に広げる必要があります。@c
これは @code{\textLengthOn} コマンドを用いることで達成できます。

@node The textLengthOn command
@unnumberedsubsubsec @code{\textLengthOn} コマンド

@cindex notes, spreading out with text (テキストに合わせて音符の間隔を広げる)

@funindex \textLengthOn
@funindex \textLengthOff

デフォルトでは、音楽のレイアウトが考慮されている限り、@c
マークアップによって作り出されるテキストは水平方向のスペースと関係しません。@c
@code{\textLengthOn} コマンドはこの動作を逆にして、@c
テキストの配置に便宜をはかる必要がある限り、音符の間隔を広げます:

@lilypond[quote,fragment,ragged-right,verbatim]
\textLengthOn  % 音符の間隔を広げてテキストに揃えます
c''2^"Text1"
c''2^"Text2" |
c''2^"Text3"
c''2^"Text4" |
@end lilypond

デフォルトの動作に戻すためのコマンドは @code{\textLengthOff} です。@c
効果を与えるのが単一の音楽タイミングであれば、@code{\textLengthOn}
に @code{\once} を付ける方法もあります。@c
リハーサルマークやテンポ記号の水平方向のスペースを調整するには、
@code{\markLengthOn} と @code{\markLengthOff} を使います。

@cindex markup text, allowing collisions (マークアップ テキストの衝突を許可する)

マークアップ テキストは譜の上に突き出している音符を避けます。@c
このことが望ましくない場合、優先度を @code{#f} にセットすることによって@c
上方向への自動再配置を Off にすることになるかもしれません。@c
ここで、マークアップ テキストがそのような音符とどのように相互作用するかを@c
示す例を挙げます。

@cindex TextScript, example of overriding (TextScript をオーバライドする例)
@cindex outside-staff-priority property, example (outside-staff-priority プロパティの例)

@lilypond[quote,ragged-right,verbatim]
\relative {
  % このマークアップは短いため衝突は起きません
  c''2^"Tex" c'' |
  R1 |

  % このマークアップは長くて納まりきらないため、上に押し上げられます
  c,,2^"Text" c'' |
  R1 |

  % 衝突回避を OFF にします
  \once \override TextScript.outside-staff-priority = ##f
  c,,2^"Long Text   " c'' |
  R1 |

  % 衝突回避を OFF にします
  \once \override TextScript.outside-staff-priority = ##f
  \textLengthOn        % そして textLengthOn を ON にします
  c,,2^"Long Text   "  % 後ろにスペースが付け加えられます
  c''2 |
}
@end lilypond


@node Dynamics placement
@unnumberedsubsubsec 強弱記号の配置

@cindex tweaking dynamics placement (強弱記号の配置を調整する)
@cindex dynamics, tweaking placement (強弱記号の配置を調整する)

通常、強弱記号は譜の下に配置されます。@c
しかしながら、@code{\dynamicUp} コマンドを使うことで上に配置される@c
かもしれません。@c
強弱記号は、その記号が付いている音符と垂直方向の関係で配置され、@c
フレージング スラーや小節番号などの譜内部オブジェクトのすべてよりも@c
下 (あるいは上) に配置されます。@c
このことは、以下の例のように、@c
到底受け入れられない結果を生み出す可能性があります:

@lilypond[quote,ragged-right,verbatim]
\relative {
  \clef "bass"
  \key aes \major
  \time 9/8
  \dynamicUp
  bes4.~\f\< \( bes4 bes8 des4\ff\> c16 bes\! |
  ees,2.~\)\mf ees4 r8 |
}
@end lilypond

しかしながら、音符とそれに付けられた強弱記号が互いに近い場合、@c
自動配置は後の方にある強弱記号を譜から離すことによって衝突を避けます。@c
しかし、以下のかなり不自然な例が示すように、@c
それは最適な配置ではないかもしれません:

@lilypond[quote,ragged-right,verbatim,fragment]
\dynamicUp
\relative { a'4\f b\mf a\mp b\p }
@end lilypond

@noindent
@q{実際} の音楽で同じような状況があった場合、音符の間隔をもう少し広げて、@c
すべての強弱記号が譜から垂直方向に同じだけ離れるようにする方が@c
望ましいかもしれません。@c
マークアップ テキストの場合は @code{\textLengthOn} コマンドを@c
用いることによってそうすることができますが、@c
強弱記号には等価のコマンドがありません。@c
そのため、@code{\override} コマンドを用いてそれを達成する方法を@c
見出す必要があります。

@node Grob sizing
@unnumberedsubsubsec グラフィカル オブジェクトのサイズ

@cindex grob sizing (グラフィカル オブジェクトのサイズを決定する)
@cindex sizing grobs (グラフィカル オブジェクトのサイズを決定する)

まず最初に、グラフィカル オブジェクトのサイズがどのように決定されるかを@c
学ばなくてはなりません。@c
すべてのグラフィカル オブジェクトの内部では参照ポイントが定義され、@c
それはそれらの親オブジェクトとの相対位置を決定するために使用されます。@c
このポイントは親オブジェクトから垂直方向に @code{X-offset}、@c
垂直方向に @code{Y-offset} 離れた位置になります。@c
オブジェクトの水平方向の広がりは数値のペア @code{X-extent} で与えられ、@c
そのペアはオブジェクトの左端と右端の参照ポイントとの相対関係について@c
述べています。@c
垂直方向の広がりも同様に数値のペア @code{Y-extent} によって与えられます。@c
これらは @code{grob-interface} をサポートする@c
すべてのグラフィカル オブジェクトが持つプロパティです。

@cindex @code{extra-spacing-width}

デフォルトでは、譜外部オブジェクトには 0 の幅が与えられているため、@c
水平方向で重なる可能性があります。@c
これは @code{extra-spacing-width} に @code{'(+inf.0 . -inf.0)} を@c
セットすることによって、左端の広がりをプラス無限大に、右端の広がりを@c
マイナス無限大にするというトリックによって達成されています。@c
譜外部オブジェクトが水平方向で重ならないことを保証するには、@c
@code{extra-spacing-width} の値をオーバライドし、余分なスペースを少しだけ@c
作る必要があります。単位は 2 つの譜線の間隔なので、左端を 0.5 単位左に、@c
右端を 0.5 単位右に動かすことで実現できます:

@example
\override DynamicText.extra-spacing-width = #'(-0.5 . 0.5)
@end example

@noindent
これが前の例で機能するかどうかを見てみましょう:

@cindex DynamicText, example of overriding (DynamicText をオーバライドする例)
@cindex extra-spacing-width property, example (extra-spacing-width プロパティの例)

@lilypond[quote,ragged-right,verbatim,fragment]
\dynamicUp
% Extend width by 1 staff space
\override DynamicText.extra-spacing-width = #'(-0.5 . 0.5)
\relative { a'4\f b\mf a\mp b\p }
@end lilypond

@noindent
これで前よりも良くなりました。@c
しかし、強弱記号が音符に合わせて上下するよりも、@c
同じベースラインで揃っている方が望ましいでしょう。@c
それを行うためのプロパティは @code{staff-padding} であり、@c
衝突に関するセクションでカバーされています
(@ref{Collisions of objects} を参照してください)。


@node Vertical spacing
@section 垂直方向のスペース

基本的に、LilyPond のオブジェクトにおける垂直方向のスペーシングは非常に@c
良いです。2 声とピアノ伴奏からなる単純な曲でどのようになるかを見てみましょう:

@lilypond[quote,fragment,ragged-right]
<<
  \new ChoirStaff
  <<
    \new Staff {
      \new Voice = "music" {
        b'2 c' c' c'
      }
    }
    \new Lyrics
    \lyricsto "music" {
      Here are some lyrics
    }
    \new Staff {
      \clef bass e'2 f e c
    }
  >>
  \new PianoStaff
  <<
    \new Staff {
      g''2 c'' c'' a''
    }
    \new Staff {
      \clef bass e2 f c e
    }
  >>
>>
@end lilypond

垂直方向のスペースについて、何もおかしな所はありません。しかし、あなたが@c
出版社と共に作業していて、譜と歌詞の垂直方向のスペースについてある要求が@c
ある場合を想像してください: 歌詞が音符から離れて配置されるように、@c
ピアノ伴奏が歌のパートから離れて配置されるように、ピアノ伴奏の 2 つの譜が@c
近づけて配置されるように要求されたとします。まず歌詞から取り組み始めましょう。

歌詞はシステム (訳注: 1 行分の譜のまとまり) 内に配置されています。@c
そのため、歌詞のスペースを調整するコマンドは@c
@rnotationnamed{Flexible vertical spacing within systems, システム内部の可変な垂直方向のスペース} にあります。@c
これによると、歌詞は @code{non-staff lines} (譜ではない行) であるため、@c
このスペースを変更するコマンドは @code{nonstaff} プロパティと関連する@c
ということが分かります。歌詞と関連している (上の段の) 譜とのスペースを@c
広げるには @code{relatedstaff} プロパティ、下の段とのスペースを広げるには
@code{unrelatedstaff} プロパティを使います。@c
歌のパートは @code{VerticalAxisGroup} の一部であるため、そのプロパティを@c
調整する必要があります。試してみて、効果があるか見てみましょう:

@lilypond[quote,fragment,ragged-right,verbatim]
<<
  \new ChoirStaff
  <<
    \new Staff {
      \new Voice = "music" {
        b'2 c' c' c'
      }
    }
    \new Lyrics \with {
      \override VerticalAxisGroup.
        nonstaff-relatedstaff-spacing.padding = #5
      \override VerticalAxisGroup.
        nonstaff-unrelatedstaff-spacing.padding = #5
    }
    \lyricsto "music" {
      Here are some lyrics
    }
    \new Staff {
      \clef bass e'2 f e c
    }
  >>
  \new PianoStaff
  <<
    \new Staff {
      g''2 c'' c'' a''
    }
    \new Staff {
      \clef bass e2 f c e
    }
  >>
>>
@end lilypond

確かに反映されました。しかしやり過ぎかもしれません。@code{padding}
プロパティを 5 に設定すると、LilyPond は 5 譜スペースをオブジェクト間の@c
距離に追加します。これは今回は大きすぎるので、2 を使用しましょう。

次に、ピアノ伴奏を歌のパートから離しましょう。歌は @code{ChoirStaff}
であるため、この譜のグループと下にあるピアノ譜とのスペースを増やす必要が@c
あります。@code{StaffGrouper} の @code{staffgroup-staff-spacing} にある
@code{basic-distance} を変更することで行います。

@lilypond[quote,fragment,ragged-right,verbatim]
<<
  \new ChoirStaff \with {
    \override StaffGrouper.
      staffgroup-staff-spacing.basic-distance = #15
  }
  <<
    \new Staff {
      \new Voice = "music" {
        b'2 c' c' c'
      }
    }
    \new Lyrics \with {
      \override VerticalAxisGroup.
        nonstaff-relatedstaff-spacing.padding = #2
      \override VerticalAxisGroup.
        nonstaff-unrelatedstaff-spacing.padding = #2
    }
    \lyricsto "music" {
      Here are some lyrics
    }
    \new Staff {
      \clef bass e'2 f e c
    }
  >>
  \new PianoStaff
  <<
    \new Staff {
      g''2 c'' c'' a''
    }
    \new Staff {
      \clef bass e2 f c e
    }
  >>
>>
@end lilypond

完璧です。さて、ピアノ譜をお互いに近づける最後の要求に応えましょう。@c
そのためには、また @code{StaffGrouper} のプロパティを変更しますが、今回は@c
@code{basic-distance} と @code{padding} の両方の値を減らします。@c
このようにして行います。

@lilypond[quote,fragment,ragged-right,verbatim]
<<
  \new ChoirStaff \with {
    \override StaffGrouper.
      staffgroup-staff-spacing.basic-distance = #15
  }
  <<
    \new Staff {
      \new Voice = "music" {
        b'2 c' c' c'
      }
    }
    \new Lyrics \with {
      \override VerticalAxisGroup.
        nonstaff-relatedstaff-spacing.padding = #2
      \override VerticalAxisGroup.
        nonstaff-unrelatedstaff-spacing.padding = #2
    }
    \lyricsto "music" {
      Here are some lyrics
    }
    \new Staff {
      \clef bass e'2 f e c
    }
  >>
  \new PianoStaff \with {
    \override StaffGrouper.staff-staff-spacing = #'(
                            (basic-distance . 0)
                            (padding . 0))
  }
  <<
    \new Staff {
      g''2 c'' c'' a''
    }
    \new Staff {
      \clef bass e2 f c e
    }
  >>
>>
@end lilypond

非常に近くなりました。しかしこれが出版社の望むものでした。@c
必要であれば、@code{padding} と @code{basic-distance} を変更することで@c
間隔を広げることができます。

垂直方向のスペースを変更する方法はたくさんあります。覚えておくべき@c
キーポイントはこれです: @code{StaffGroup} にあるオブジェクト
(例えば @code{GrandStaff} や @code{PianoStaff} のグループ) のスペースは、
@code{StaffGrouper} の変数によって操作されること、@c
グループ化されていない譜 (例えば @code{Lyrics} や @code{Staff})
のスペースは、@code{VerticalAxisGroup} の変数によって操作されることです。@c
詳しくは、@rnotation{Flexible vertical spacing paper variables} と
@rnotation{Flexible vertical spacing within systems} を参照してください。


@need 1500
@node Collisions of objects
@section オブジェクトの衝突


@node Moving objects
@subsection オブジェクトを移動させる

@cindex moving overlapping objects (重なり合っているオブジェクトを移動させる)
@cindex moving colliding objects (衝突しているオブジェクトを移動させる)
@cindex moving colliding grobs (衝突しているグラフィカル オブジェクトを移動させる)
@cindex objects, moving colliding (衝突しているオブジェクトを移動させる)
@cindex grobs, moving colliding (衝突しているグラフィカル オブジェクトを移動させる)

これを聞いて驚くかもしれませんが、LilyPond は完璧ではありません。@c
いくつかの記譜要素が重なりある可能性があります。@c
これは遺憾なことですが、実際にはごく稀です。@c
通常、オブジェクトを移動させる必要性は読みやすさや美しさのためです
-- オブジェクトの周りにもう少しスペースを多く/少なくとった方が@c
より良くなるといった場合です。

記譜要素の重なりを解決する主要なアプローチが 3 つあります。@c
それらは以下の順番で考慮されるべきです:

@enumerate
@item
重なり合っているオブジェクトの 1 つの @strong{direction} を
@ref{Within-staff objects} でリストアップした内部オブジェクトのための@c
定義済みコマンドを用いて変更することになるかもしれません。@c
符幹、スラー、連桁、タイ、強弱記号、テキスト、@c
連符はこの方法で容易に再配置できるかもしれません。@c
この方法の限界は配置の仕方の選択肢が 2 つしかないことであり、@c
どちらも適当でないかもしれません。

@item
LilyPond がレイアウト オブジェクトを配置するときに使用する@c
@strong{オブジェクト プロパティ}を @code{\override} を用いて@c
変更することになるかもしれません。@c
オブジェクト プロパティに変更を加えることの利点は、@c
(a) スペースをとる必要がある場合に他のいくつかのオブジェクトは@c
自動的に移動させられます、@c
(b) 1 回のオーバライドを同じオブジェクト タイプの@c
インスタンスすべてに適用することができます。@c
変更するプロパティには以下のものが含まれます:

@itemize

@item
@code{direction}

これはすでに詳しくカバーされています --
@ref{Within-staff objects} を参照してください。

@item
@code{padding}, @code{left-padding},
@code{right-padding}, @code{staff-padding}

@cindex padding (パディング)
@cindex left-padding property (left-padding プロパティ)
@cindex padding property (padding プロパティ)
@cindex right-padding property (right-padding プロパティ)
@cindex staff-padding property (staff-padding プロパティ)

あるオブジェクトが配置されるとき、そのオブジェクトの
@code{padding} プロパティが、そのオブジェクトとそのオブジェクトに@c
最も隣接するオブジェクトの端との間に置かれる間隔を指定します。@c
@strong{配置される最中}のオブジェクトの @code{padding} 値が@c
使用されるということに注意してください。@c
すでに配置されたオブジェクトの @code{padding} 値は無視されます。@c
@code{padding} によって指定された間隔は @code{side-position-interface} を@c
サポートするオブジェクトすべてに適用することができます。

臨時記号のグループの配置は、@code{padding} の代わりに、@code{left-padding} と
@code{right-padding} によって制御されます。@c
これらのプロパティは @code{AccidentalPlacement} オブジェクトの中にあり、@c
注意すべきことに、そのオブジェクトは
@strong{Staff} コンテキストの中にあります。@c
譜刻プロセスでは、符頭が最初に譜刻され、臨時記号 (がある場合は) が@c
次に符頭の左側に付け加えられます。@c
このとき、臨時記号と符頭の間隔は
@code{right-padding} プロパティによって指定されます。@c
そのため、@code{AccidentalPlacement} オブジェクトの
@code{right-padding} プロパティだけが臨時記号の配置に影響を与えます。

@code{staff-padding} プロパティは @code{padding} プロパティと@c
深い関わりがあります:
@code{padding} プロパティは、@code{side-position-interface} を@c
サポートするオブジェクトとそれに最隣接する他のオブジェクト
(一般には音符や譜線) との間のスペースの最小量を制御します。@c
一方、@code{staff-padding} は常に譜の外側に配置される@c
レイアウト オブジェクトにのみ適用されます --
これは譜の外側に配置されるオブジェクトと譜の間に挿入されるべき@c
スペースの最小量を制御します。@c
@code{staff-paddin} は譜ではなく音符との相対関係で配置されるオブジェクトには@c
影響を与えないということに注意してください。@c
そのようなオブジェクトに対して @code{staff-padding} のオーバライドを@c
行ったとしてもエラーは起きないかもしれませんが、無視されます。

あなたが再配置しようとしているオブジェクトに対して求められる
@code{padding} プロパティはどれなのかを見つけるには、内部リファレンスに@c
戻ってそのオブジェクトのプロパティを調べる必要があります。@c
@code{padding} プロパティはあなたが再配置しようとしているオブジェクトの中には@c
無いかもしれないということに注意してください。@c
その場合は、そのオブジェクトに関係があるオブジェクトを調べてください。

すべての @code{padding} 値は譜スペースで測られます。@c
たいていのオブジェクトでは、この値はデフォルトで約 1.0 か@c
それ以下にセットされています (それぞれのオブジェクトで値はさまざまです)。@c
間隔を大きく (あるいは小さく) する必要がある場合、@c
その値はオーバライドされるかもしれません。

@item
@code{self-alignment-X}

@cindex self-alignment-X property (self-alignment-X プロパティ)

このプロパティを使うことで、親オブジェクトの参照ポイントに従って、@c
オブジェクトを左、右、中央に揃えることができます。@c
このプロパティは @code{self-alignment-interface} をサポートする@c
オブジェクトすべてに対して使用することができます。@c
一般に、テキストを保持するオブジェクトです。@c
値は @code{Left}, @code{RIGHT}, @code{CENTER} です。@c
代替手段として、@w{@code{-1}} から @code{+1} までの数値を@c
指定することもできます。@c
@code{-1} は左揃えであり、@code{+1} は右揃え、@c
その間の数値は左揃えから右揃えへのテキストを移動させます
(訳者: @code{-0.5} であれば、左揃えと中央揃えの中間ということ)。@c
@code{1} よりも大きな数値を指定することでテキストをさらに左へ、@c
@w{@code{-1}} よりも小さな数値を指定することでテキストを@c
さらに右へ移動させることができます。@c
この値を @code{1} 増減することによる移動量はそのテキストの長さの半分です。

@item
@code{extra-spacing-width}

@cindex extra-spacing-width property (extra-spacing-width プロパティ)

このプロパティは @code{item-interface} をサポートするオブジェクトすべてで@c
利用可能です。@c
このプロパティは 2 つの数値をとり、最初の数値はオブジェクトの左側に@c
余白を追加し、2 番目の数値はオブジェクトの右側に余白を追加します。@c
負値はオブジェクトの端を左に移動させ、正値は右に移動させます。@c
そのため、オブジェクトを広くするには、最初の数値を負値にして、@c
2 番目の数値を正値にする必要があります。@c
すべてのオブジェクトが両方の数値を遵守するわけではないということに@c
注意してください。@c
例えば、@code{Accidental} オブジェクトは最初の数値 (左端) にしか@c
注意を払いません。

@item
@code{staff-position}

@cindex staff-position property (staff-position プロパティ)

@code{staff-position} は @code{staff-symbol-referencer-interface} の@c
プロパティです。@c
これは、譜との相対関係で配置されるオブジェクトによってサポートされます。@c
このプロパティはオブジェクトの垂直方向の位置を、譜の中央にある譜線から@c
譜スペースの半分を単位として、指定します。@c
このプロパティは複数小節に亘る休符、タイ、異なるボイスの中にある音符といった@c
レイアウト オブジェクトの衝突を解決する場合に有用です。

@item
@code{horizontal-shift}

@cindex horizontal-shift property (horizontal-shift プロパティ)
@cindex note column (音符列)
@cindex note collisions (音符の衝突)
@cindex collisions, notes (音符の衝突)
@cindex shift commands (シフト コマンド)
@funindex \shiftOff
@funindex \shiftOn
@funindex \shiftOnn
@funindex \shiftOnnn

ボイスの中で、同じタイミングにある全ての音符は 1 つの音符列にグループ化され、@c
@code{NoteColumn} オブジェクトがその音符のグループの水平位置をコントロールする@c
ために作成されます (@ref{Explicitly instantiating voices} の
@qq{Note columns} を参照してください)。
もし 1 つの Staff コンテキストにある 2 つ以上の音符列が、同じタイミングで@c
出現し同じ向きの符幹を持つ場合@emph{に限り}、それらの @code{horizontal-shift}
プロパティの値が順位を付けるために使用され、高い順位にあるものが優先的に@c
符頭の衝突を避けるために移動します。このプロパティは @code{\voiceXXX}
コマンドによってセットされ、@code{\override} コマンドで直接上書きすることが@c
できますが、通常は @code{\shiftOn} コマンドによって上書きします。@c
注意しなければならないことは、このプロパティは移動の @emph{順位} を@c
決定するだけだけであり、移動の大きさを決定するものではないということです。
移動の大きさは、順位ごとに符頭の幅を基にして 1 つずつ大きくなっていきます。@c
1 つ分の幅は通常符頭の幅の半分ですが、それで近い場合には符頭 1 つ分の幅に@c
なります。

@item
@code{force-hshift}

@cindex force-hshift property (force-hshift プロパティ)

@code{force-hshift} プロパティは @code{NoteColumn} のプロパティです
(実際には @code{note-column-interface} のプロパティです)。@c
このプロパティを変更することで、音符列が重なってしまう場合において@c
音符列を移動させることができます。重ならない音符列には効果が無いということに@c
注意してください。移動の量は音符列特有の単位、すなわち最初のボイスの@c
中にある音符の符頭の幅で指定されます。
このプロパティは、通常の
@code{\shiftOn} コマンド
(@ref{Explicitly instantiating voices} を参照してください)
が音符の衝突を十分に解決できないような複雑な状況で使用されるべきです。@c
この目的のためには、@code{extra-offset} プロパティを用いるよりも
@code{force-hshift} プロパティを用いる方が好ましいです。@c
なぜなら、譜スペースを単位とした距離を算出する必要が無く、@c
@code{NoteColumn} の内外に音符を移動させることは符頭のマージといった@c
他のアクションに影響を与えるからです。

@end itemize

@item
最後に、他の方法がすべて失敗した場合、オブジェクトを手動で譜の中央線からの@c
垂直方向の相対位置に従って、あるいは新たに設定した位置との距離に従って、@c
再配置することになるかもしれません。@c
この方法の欠点は、再配置のための正確な値を算出する必要がある --
しばしば、その算出はそれぞれのオブジェクトに対して個々に、トライ＆エラーで@c
行われます -- 必要があるということ、さらに、この方法による移動は
LilyPond が他のオブジェクトをすべて配置した後に行われるため、@c
ユーザはその結果として起こるかもしれない衝突を@c
すべて回避する責任があるということです。@c
しかし、この方法の最大の問題点は、音楽が後で変更された場合に、@c
再配置用の値を再び算出する必要があるということです。@c
このタイプの手動再配置のために使用されるプロパティは以下のようなものです:

@table @code
@item extra-offset

@cindex extra-offset property (extra-offset プロパティ)

このプロパティは @code{grob-interface} をサポートするレイアウト オブジェクトの@c
いずれかに適用されます。@c
このプロパティはペアになった数値をとり、それぞれの数値は@c
水平方向と垂直方向の移動を指定します。@c
負値はオブジェクトを左または下へ移動させます。@c
単位は譜スペースです。@c
この移動はオブジェクトの譜刻が完了した後に行われるため、あるオブジェクトを@c
任意の位置へ、他のオブジェクトに影響を与えることなく、再配置することができます。

@item positions

@cindex positions property (positions プロパティ)

このプロパティは、連桁、スラー、連符の傾きと高さを手動で調節するために@c
最も有用なプロパティです。@c
このプロパティはペアになった数値をとり、それぞれの数値は連桁、@c
スラーなどの左端と右端の位置を譜の中央線との距離で指定します。@c
単位は譜スペースです。@c
けれども、スラーとフレージング スラーを任意の値で@c
再配置することはできないということに注意してください。@c
LilyPond はまずスラーが取り得る位置のリストを生成し、それからデフォルトでは
@qq{最良に見える} スラーを探します。@c
@code{positions} がオーバライドされていた場合、@c
そのリストの中からリクエストされた位置に最も近いスラーが選択されます。
@end table

@end enumerate

あるオブジェクトがこれらのプロパティすべてを持っているわけではありません。@c
内部リファレンスに行き、そのオブジェクトではどのプロパティが@c
利用可能なのかを調べる必要があります。

ここで、衝突に関係しそうなオブジェクトをリスト アップします。@c
内部リファレンスを調べるためのオブジェクト名を付けるので、@c
それらのオブジェクトを移動させるのに使うプロパティを見つけ出すのに@c
使ってください。

@multitable @columnfractions .5 .5
@headitem オブジェクト タイプ                    @tab オブジェクト名
@item アーティキュレーション (Articulation)      @tab @code{Script}
@item 連桁 (Beam)                                @tab @code{Beam}
@item 強弱記号 (Dynamic) (垂直方向)              @tab @code{DynamicLineSpanner}
@item 強弱記号 (Dynamic) (水平方向)              @tab @code{DynamicText}
@item 運指法記号 (Fingering)                     @tab @code{Fingering}
@item リハーサル / テキスト記号 (Rehearsal / Text mark) @tab @code{RehearsalMark}
@item スラー (Slur)                                @tab @code{Slur}
@item テキスト -- つまり、@code{^"text"} (Text)  @tab @code{TextScript}
@item タイ (Tie)                                 @tab @code{Tie}
@item 連符 (Tuplet)                              @tab @code{TupletBracket}
@end multitable


@node Fixing overlapping notation
@subsection 表記の重なりを修正する

今度は、前のセクションで扱ったプロパティが記譜の重なりを解決する手助けを@c
どのようにできるかを見ていきましょう。


@node The padding property
@unnumberedsubsubsec @code{padding} プロパティ

@cindex padding (パディング)
@cindex fixing overlapping notation (記譜要素の重なりを修正する)
@cindex overlapping notation (重なり合っている記譜要素)

@code{padding} プロパティに値をセットすることによって、音符とその上または下に@c
譜刻される記号との間の距離を増減することができます。

@cindex Script, example of overriding (Script をオーバライドする例)
@cindex padding property, example (padding プロパティの例)

@lilypond[quote,fragment,verbatim]
c'2\fermata
\override Script.padding = #3
b2\fermata
@end lilypond

@cindex MetronomeMark, example of overriding (MetronomeMark をオーバライドする例)
@cindex padding property, example (padding プロパティの例)

@lilypond[quote,fragment,verbatim]
% これは機能しません。この下を見てください
\override MetronomeMark.padding = #3
\tempo 4 = 120
c'1 |
% これは機能します
\override Score.MetronomeMark.padding = #3
\tempo 4 = 80
d'1 |
@end lilypond

2 番目の例では、ある特定のオブジェクトを扱うのはどのコンテキストなのかを@c
突き止めることが重要であるということに注意してください。@c
@code{MetronomeMark} オブジェクトは @code{Score} コンテキストの中で@c
処理されるため、@code{Voice} コンテキストの中でのプロパティの変更は@c
無視されます。@c
更に詳細を知りたければ、@rnotation{Modifying properties} を参照してください。

@code{outside-staff-priority} に従って配置されているオブジェクトの並びの中の@c
あるオブジェクトの @code{padding} プロパティが増やされた場合、@c
そのオブジェクトとそれよりも外側にあるすべてオブジェクトが移動させられます。


@node The right-padding property
@unnumberedsubsubsec @code{right-padding} プロパティ

@cindex right-padding property (right-padding プロパティ)

@code{right-padding} プロパティは臨時記号とそれが適用される音符との間の@c
スペースに影響を与えます。@c
このプロパティを変更することは必ずしも必要ではありませんが、@c
微分音の音楽で使われる特殊な臨時記号の図柄や図柄の組み合わせに対して@c
デフォルトのスペースが適切ではない場合に必要となるかもしれません。@c
臨時記号のステンシルを望みのシンボルを保持するマークアップにオーバライド@c
する必要があります:

@cindex Accidental, example of overriding (Accidental をオーバライドする例)
@cindex text property, example (text プロパティの例)
@cindex stencil property, example (stencil プロパティの例)
@cindex AccidentalPlacement, example of overriding (AccidentalPlacement をオーバライドする例)
@cindex right-padding property, example (right-padding プロパティの例)

@lilypond[quote,ragged-right,verbatim]
sesquisharp = \markup { \sesquisharp }
\relative {
  c''4
  % これは 1.5 倍シャープを譜刻しますが、スペースが小さすぎます
  \once \override Accidental.stencil = #ly:text-interface::print
  \once \override Accidental.text = #sesquisharp
  cis4 c
  % これはスペースを改善しています
  \once \override Score.AccidentalPlacement.right-padding = #0.6
  \once \override Accidental.stencil = #ly:text-interface::print
  \once \override Accidental.text = #sesquisharp
  cis4 |
}
@end lilypond

@noindent
これは必然的に臨時記号のステンシルをオーバライドすることになります。@c
このオーバライドについては後々までカバーされません。@c
ステンシル タイプは手続きでなければならず、ここでは @code{Accidental} の
@code{text} プロパティの内容
-- 内容には 1.5 倍シャープがセットされています
-- を譜刻するように変更されています。@c
それらの記号は @code{right-padding} のオーバライドによって@c
符頭からさらに遠くへ移動させられています。

@noindent


@node The staff-padding property
@unnumberedsubsubsec @code{staff-padding} プロパティ

@cindex aligning objects on a baseline (オブジェクトをベースラインに揃える)
@cindex objects, aligning on a baseline (オブジェクトをベースラインに揃える)

@code{staff-padding} を使うことで、強弱記号などのオブジェクトを、@c
他のオブジェクトが譜から離すよう強制しない限り、@c
譜から一定の距離にあるベースラインに揃えることができます。@c
このプロパティは @code{DynamicText} のプロパティではなく、@c
@code{DynamicSpanner} のプロパティです。@c
この理由は、このベースラインは延長スパナを含む @strong{すべて} の強弱記号に@c
等しく適用されるべきだからです。@c
そのため、これは以前のセクションでの例の中にある強弱記号を@c
揃えるための方法になります:

@cindex DynamicText, example of overriding (DynamicText をオーバライドする例)
@cindex extra-spacing-width property, example (extra-spacing-width プロパティの例)
@cindex DynamicLineSpanner, example of overriding (DynamicLineSpanner をオーバライドする例)
@cindex staff-padding property, example (staff-padding プロパティの例)

@lilypond[quote,fragment,ragged-right,verbatim]
\override DynamicLineSpanner.staff-padding = #3
\relative { a'4\f b\mf a\p b\mp }
@end lilypond


@node The self-alignment-X property
@unnumberedsubsubsec @code{self-alignment-X} プロパティ

以下の例はこのプロパティが、運指法記号オブジェクトの右端を親の音符の@c
参照ポイントに揃えることによって、@c
弦楽器の運指法記号オブジェクトと音符の符幹との相対位置を調整している@c
様子を示しています:

@cindex StringNumber, example of overriding (StringNumber をオーバライドする例)
@cindex self-alignment-X property, example (self-alignment-X プロパティの例)

@lilypond[quote,fragment,ragged-right,verbatim]
\voiceOne
<a''\2>
\once \override StringNumber.self-alignment-X = #RIGHT
<a''\2>
@end lilypond


@node The staff-position property
@unnumberedsubsubsec @code{staff-position} プロパティ

@cindex object collision within a staff (譜内部でのオブジェクトの衝突)

あるボイスの中にある複数小節に亘る休符は他のボイスの中にある音符と@c
衝突する可能性があります。@c
このような休符は小節線と小節線の間の中央に譜刻されるため、@c
LilyPond がそれと衝突するかもしれない音符を突き止めるのは非常に困難です。@c
なぜなら、現在の音符間それに音符-休符間の衝突対応は、@c
同時に起こる音符と休符に対してのみ行われるからです。@c
以下に、このタイプの衝突の例を挙げます:

@lilypond[quote,verbatim,ragged-right]
<< \relative { c'4 c c c } \\ { R1 } >>
@end lilypond

ここでの最良の解決策は、複数小節に亘る休符を下へ移動させることです。@c
なぜなら、その休符はボイス 2 の中にあるからです。@c
@code{\voiceTwo} (すなわち、@code{<<@{@dots{}@} \\ @{@dots{}@}>>} 構造の
2 番目のボイス) のデフォルト状態では、@c
@code{MultiMeasureRest} の @code{staff-position} は @code{-6} に@c
セットされています。@c
そのため、そのプロパティを、例えば半譜スペース 4 つ分押し下げるには、@c
@w{@code{-10}} に変更する必要があります。

@cindex MultiMeasureRest, example of overriding (MultiMeasureRest をオーバライドする例)
@cindex staff-position property, example (staff-position プロパティの例)

@lilypond[quote,verbatim,ragged-right]
<<
  \relative { c'4 c c c }
  \\
  \override MultiMeasureRest.staff-position = #-10
  { R1 }
>>
@end lilypond

これは、例えば @code{extra-offset} を使うよりも良い解決方法です。@c
なぜなら、その休符の上に加線が自動的に挿入されるからです。

正確な値と不正確な値の違いについては、
@rnotation{Engraving ties manually} を参照してください。


@node The extra-offset property
@unnumberedsubsubsec @code{extra-offset} プロパティ

@cindex positioning objects (オブジェクトの位置を決定する)
@cindex positioning grobs (グラフィカル オブジェクトの位置を決定する)
@cindex objects, positioning (オブジェクトの位置を決定する)
@cindex grobs, positioning (グラフィカル オブジェクトの位置を決定する)

@code{extra-offset} プロパティは、あるオブジェクトの水平方向と垂直方向の@c
配置を完全に制御します。

以下の例では、2 番目の運指法記号が少し左に、そして 1.8 譜スペース下に@c
移動させられています:

@cindex Fingering, example of overriding (Fingering をオーバライドする例)
@cindex extra-offset property, example (extra-offset プロパティの例)

@lilypond[quote,fragment,verbatim]
f'4-5
\once \override Fingering.extra-offset = #'(-0.3 . -1.8)
f'4-5
@end lilypond


@node The positions property
@unnumberedsubsubsec @code{positions} プロパティ

@cindex controlling tuplets, slurs, phrasing slurs, and beams manually (連符、スラー、フレージング スラーそれに連桁を手動で制御する)
@cindex manually controlling tuplets, slurs, phrasing slurs, and beams (連符、スラー、フレージング スラーそれに連桁を手動で制御する)
@cindex tuplet beams, controlling manually (連譜の連桁を手動で制御する)
@cindex slurs, controlling manually (スラーを手動で制御する)
@cindex phrasing slurs, controlling manually (フレージング スラーを手動で制御する)
@cindex beams, controlling manually (連桁を手動で制御する)

@code{positions} プロパティは連符、スラー、フレージング スラー、@c
連桁の位置を手動で制御することができ、それにより傾きも制御できます。

ここで、フレージング スラーとスラーが衝突している例を示します:

@lilypond[quote,verbatim,ragged-right]
\relative { a'8 \( ( a'16 ) a \) }
@end lilypond

@cindex PhrasingSlur, example of overriding (PhrasingSlur をオーバライドする例)
@cindex positions property, example (positions プロパティの例)

@noindent
衝突を解決するために、フレージング スラーの両端を上に移動させます。@c
左端を譜中央線よりも 2.5 譜スペース上に設定し、右端を 4.5 譜スペース上に@c
設定すると、LilyPond は候補の中から両端の位置が最も設定に近いフレージング
スラーを選択します:

@lilypond[quote,verbatim,fragment,ragged-right]
\once \override PhrasingSlur.positions = #'(2.5 . 4.5)
a'8 \( ( a''16 ) a'' \)
@end lilypond

これで改善されました。@c
しかしながら、スラーの右端を少し下げてみてはどうでしょうか？@c
そうしようとした場合、この方法では実行できないことがわかります。@c
すでに表示されているスラーよりも右端が下がっている候補は無く、@c
そのような場合には @code{positions} は効果を持たないからです。@c
しかしながら、必要があればタイ、スラー、それにフレージング スラーの@c
位置と形状を非常に正確に設定することが @emph{できます}。@c
正確な設定を行う方法は @rnotation{Modifying ties and slurs} で学習してください。

もう 1 つ例を示します。@c
連桁がタイと衝突しています:

@lilypond[quote,verbatim,ragged-right]
{
  \time 4/2
  <<
    \relative { c'1~ 2. e8 f }
    \\
    \relative {
      e''8 e e e
      e e e e
      f2 g
    }
  >>
  <<
    \relative { c'1~ 2. e8 f }
    \\
    \relative {
      e''8 e e e
      e e e e
      f2 g
    }
  >>
}
@end lilypond

@noindent
これは、譜の中央線から 1.81 譜スペース上の位置にある連桁の両端を、例えば、1
に手動で上げることによって解決することができます:

@cindex Beam, example of overriding (Beam をオーバライドする例)
@cindex positions property, example (positions プロパティの例)

@lilypond[quote,verbatim,ragged-right]
{
  \time 4/2
  <<
    \relative { c'1~ 2. e8 f }
    \\
    \relative {
      \override Beam.positions = #'(-1 . -1)
      e''8 e e e
      e e e e
      f2 g
    }
  >>
  <<
    \relative { c'1~ 2. e8 f }
    \\
    \relative {
      e''8 e e e
      e e e e
      f2 g
      \revert Beam.positions
    }
  >>
}
@end lilypond

@noindent
オーバライドの効果は継続して第 2 小節のボイス 2 の 8 分音符にも@c
適用されていますが、@c
ボイス 1 の連桁には、その後の第 2 小節においても@c
まったく適用されていないということに注意してください。@c
例に示したように、オーバライドがもう適用されるべきでないところでは@c
オーバライドをリバートするべきです。

@node The force-hshift property
@unnumberedsubsubsec @code{force-hshift} プロパティ

今や、@ref{I'm hearing voices} の最後で挙げた Chopin の例に@c
どのように修正を加えるべきかを知っています。@c
この例は以下のような状態でした:

@lilypond[quote,verbatim,fragment,ragged-right]
\new Staff \relative {
  \key aes \major
  <<
    { c''2 aes4. bes8 }
    \\
    { <ees, c>2 des }
    \\
    \\
    { aes'2 f4 fes }
  >> |
  <c ees aes c>1 |
}
@end lilypond

@noindent
最初の和音の内声の音 (つまり、4 番目のボイスにある A-フラット) を上の音符の@c
音符列からずらす必要はありません。そのために @code{\shiftOff} を用います。@c

2 番目の和音では、F を A-フラットに揃えて、符幹の衝突を避けるために@c
最下段の音符を少し右に移動させるべきでしょう。@c
そうするには、D-フラットの @code{NoteColumn} の @code{force-hshift}
を設定して譜スペースの半分だけ右にずらし、F の @code{force-hshift}
をゼロにします。@c
注意すべきことは、すぐ後のタイミングを越えて設定が伝播してしまわないように、
@code{\once} を使っているということです。
この小さい例においては、ボイス 4 の @code{\once} と 2 個目の
@code{\override} (訳注: @code{\shiftOff} のこと) は省略できますが、@c
それは良い方法ではありません。

ここで、最終結果を挙げます:

@cindex NoteColumn, example of overriding (NoteColumn をオーバライドする例)
@cindex force-hshift property, example (force-hshift プロパティの例)

@lilypond[quote,verbatim,fragment,ragged-right]
\new Staff \relative {
  \key aes \major
  <<
    { c''2 aes4. bes8 }
    \\
    { <ees, c>2 \once \override NoteColumn.force-hshift = 0.5 des }
    \\
    \\
    { \once \shiftOff aes'2 \once \shiftOff f4 fes }
  >> |
  <c ees aes c>1 |
}
@end lilypond


@node Real music example
@subsection 実際の音楽からの例

調整についてのセクションを、望みの出力を作り出すためにいくつかの調整を@c
必要とするトリッキーな例を処理するときにとられるステップを示すことで@c
締めくくります。@c
この例は、記譜法についての普通ではない問題を解決するための記譜法リファレンスの@c
使い方を示すために慎重に選ばれたものです。@c
この例は一般的な譜刻プロセスを代表するものではありません。@c
ですから、この例の複雑さでやる気を失わないでください！@c
幸いなことに、このように複雑な問題は非常に稀です！

この例は Chopin の Première Ballade, Op. 23 の第 6 - 9 小節からとりました。@c
序盤の Lento から Moderato へと移調する部分です。@c
まず最初に望んでいる出力挙げますが、例があまりにも複雑になり過ぎないように@c
強弱記号、運指法記号、ペダル記号は省きました。

@c The following should appear as music without code
@c This example should not be indexed
@c line-width ensures no break
@lilypond[quote,ragged-right,line-width=6\in]
rhMusic = \relative {
  \new Voice {
    r2 c''4.\( g8 |
    \once \override Tie.staff-position = #3.5
    bes1~ |
    \bar "||"
    \time 6/4
    \mergeDifferentlyHeadedOn
    \mergeDifferentlyDottedOn
    bes2.\tempo "Moderato" r8
    <<
      { c,8 d fis bes a }
      \new Voice {
        \voiceTwo
        c,8~
        % マージされる音符の右にある c2 を再配置します
        \once \override NoteColumn.force-hshift = #1.0
        % c2 をメインの音符列から外したため、
        % マージが機能します
        \shiftOnn
        c2
      }
      \new Voice {
        \voiceThree
        s8
        % マージさせるために d2 の符幹を下向きにする必要があります
        \stemDown
        % d2 の符幹を不可視にします
        \tweak Stem.transparent ##t
        d2
      }
      \new Voice {
        \voiceFour
        s4 fis4.
      }
    >> |
    \mergeDifferentlyHeadedOff
    \mergeDifferentlyDottedOff
    g2.\)
  }
}

lhMusic = \relative {
  r2 <c' g ees>2( |
  <d g, d>1)\arpeggio |
  r2. d,,4 r4 r |
  r4
}

\score {
  \new PianoStaff <<
    \new Staff = "RH"  <<
      \key g \minor
      \rhMusic
    >>
    \new Staff = "LH" <<
      \key g \minor
      \clef "bass"
      \lhMusic
    >>
  >>
}
@end lilypond

まず、第 3 小節の右手パートには 4 つのボイスが必要であることに注目します。@c
それぞれのボイスは、連桁でつながれた 5 つの 8 分音符、タイで結ばれた C、@c
半音符の D (これは 8 分音符の D とマージされています)、@c
付点 4 分音符の F シャープ (これも同じピッチの 8 分音符とマージされています)
です。@c
他の部分はすべて単一のボイスなので、最も容易な方法は
4 つのボイスを必要になったときに一時的に導入する方法です。@c
一時的に多声にする方法を忘れてしまったのならば、@c
@ref{I'm hearing voices} と @ref{Explicitly instantiating voices}
を参照してください。@
ここでは、多声パッセージに明示的にインスタンス化されたボイスを使うことにします。@c
なぜなら、すべてのボイスが明示的にインスタンス化されている方が、@c
LilyPond はうまく衝突を回避できるからです。

音符を 2 つの変数として入力し、@c
譜構造を Score ブロックの中でセットアップすることから始めて、@c
それで LilyPond がデフォルトでどのような出力を作り出すのか見てみましょう:

@c line-width ensures no break
@lilypond[quote,verbatim,ragged-right,line-width=6\in]
rhMusic = \relative {
  \new Voice {
    r2 c''4. g8 |
    bes1~ |
    \time 6/4
    bes2. r8
    % 4 つのボイスの多声セクションの開始
    <<
      { c,8 d fis bes a }  % メイン ボイスの続き
      \new Voice {
        \voiceTwo
        c,8~ 2
      }
      \new Voice {
        \voiceThree
        s8 d2
      }
      \new Voice {
        \voiceFour
        s4 fis4.
      }
    >> |
    g2.  % メイン ボイスの続き
  }
}

lhMusic = \relative {
  r2 <c' g ees>2 |
  <d g, d>1 |
  r2. d,,4 r4 r |
  r4
}

\score {
  \new PianoStaff <<
    \new Staff = "RH"  <<
      \key g \minor
      \rhMusic
    >>
    \new Staff = "LH" <<
      \key g \minor
      \clef "bass"
      \lhMusic
    >>
  >>
}
@end lilypond

すべての音符は間違っていません。@c
しかしながら、見た目は満足とは程遠いものです。@c
タイは移調する拍子記号と衝突していて、第 3 小節の連桁の付け方は@c
間違っていて、音符はマージされておらず、いくつかの記譜要素は欠けています。@c
簡単なものから片付けていきましょう。@c
連桁の付け方は手動で連桁を挿入することで修正でき、左手パートのスラーと@c
右手パートのフレージング スラーは簡単に追加できます
-- なぜなら、これらはすべてチュートリアルでカバーされているからです。@c
これらの修正を加えると、以下のようになります:

@c line-width ensures no break
@lilypond[quote,verbatim,ragged-right,line-width=6\in]
rhMusic = \relative {
  \new Voice {
    r2 c''4.\( g8 |
    bes1~ |
    \time 6/4
    bes2. r8
    % 4 つのボイスの多声セクションの開始
    <<
      { c,8 d fis bes a }  % メイン ボイスの続き
      \new Voice {
        \voiceTwo
        c,8~ 2
      }
      \new Voice {
        \voiceThree
        s8 d2
      }
      \new Voice {
        \voiceFour
        s4 fis4.
      }
    >> |
    g2.\)  % メイン ボイスの続き
  }
}

lhMusic = \relative {
  r2 <c' g ees>2( |
  <d g, d>1) |
  r2. d,,4 r4 r |
  r4
}

\score {
  \new PianoStaff <<
    \new Staff = "RH"  <<
      \key g \minor
      \rhMusic
    >>
    \new Staff = "LH" <<
      \key g \minor
      \clef "bass"
      \lhMusic
    >>
  >>
}
@end lilypond

第 1 小節は正しくなりました。@c
第 2 小節にはアルペジオが含まれていて、2 重の小節線で終わります。@c
この学習マニュアルではこれらのことは言及されてこなかったのに、@c
どうやってやればいいのでしょうか？@c
ここで、記譜法リファレンスに移行する必要があります。@c
索引で @q{arpeggio} と @q{bar line} を探せばすぐに、アルペジオは
@code{\arpeggio} を和音の後に付け加えることによって作り出され、@c
2 重小節線は @code{\bar "||"} コマンドによって作り出されることが@c
わかります。@c
それは簡単にできます。@c
次に、タイと拍子記号の衝突を修正する必要があります。@c
これはタイを上に移動させる方法が最善です。@c
オブジェクトの移動については以前に @ref{Moving objects} でカバーしました。@c
そこでは、譜との相対位置で配置されるオブジェクトは、@c
そのオブジェクトの @code{staff-position} プロパティを@c
オーバライドすることによって、移動させることができると述べられています。@c
このプロパティは譜スペースの半分を単位として、譜の中央線からの距離で@c
指定されます。@c
ですから、以下の以下のオーバライドをタイで結ばれる最初の音符の前に置けば、@c
タイは中央線から 3.5 半譜スペースだけ上の位置に移動させられます:

@code{\once \override Tie.staff-position = #3.5}

これで第 2 小節の修正も完了で、以下のようになります:

@c line-width ensures no break
@lilypond[quote,verbatim,ragged-right,line-width=6\in]
rhMusic = \relative {
  \new Voice {
    r2 c''4.\( g8 |
    \once \override Tie.staff-position = #3.5
    bes1~ |
    \bar "||"
    \time 6/4
    bes2. r8
    % 4 つのボイスの多声セクションの開始
    <<
      { c,8 d fis bes a }  % メイン ボイスの続き
      \new Voice {
        \voiceTwo
        c,8~ 2
      }
      \new Voice {
        \voiceThree
        s8 d2
      }
      \new Voice {
        \voiceFour
        s4 fis4.
      }
    >> |
    g2.\)  % メイン ボイスの続き
  }
}

lhMusic = \relative {
  r2 <c' g ees>2( |
  <d g, d>1)\arpeggio |
  r2. d,,4 r4 r |
  r4
}

\score {
  \new PianoStaff <<
    \new Staff = "RH"  <<
      \key g \minor
      \rhMusic
    >>
    \new Staff = "LH" <<
      \key g \minor
      \clef "bass"
      \lhMusic
    >>
  >>
}
@end lilypond

第 3 小節 -- Moderato セクションの開始部分 -- に取り掛かります。@c
チュートリアルで @code{\tempo} コマンドを使ってテンポ表示を@c
付け加える方法を示しましたので、@q{Moderato} を付け加えることは@c
容易です。@c
しかし、異なるボイスの中にある音符をマージするにはどうするのでしょうか？@c
ここで、助けを求めて記譜法リファレンスに移行する必要があります。@c
記譜法リファレンスで @qq{merge} を探せばすぐに、@c
@rnotation{Collision resolution} で符頭や付点の付き方が異なる音符を@c
マージするためのコマンドにたどり着きます。@c
今回の例では、多声部セクションで両方のタイプの音符をマージする
(異なる符頭を持つ音符のマージと、付点の付き方が異なる音符のマージ)
必要があるので、記譜法リファレンスで見つけた情報を使って、以下のコマンド:

@example
\mergeDifferentlyHeadedOn
\mergeDifferentlyDottedOn
@end example

@noindent
を多声部セクションの開始点に置き、以下のコマンド:

@example
\mergeDifferentlyHeadedOff
\mergeDifferentlyDottedOff
@end example

@noindent
をセクションの終了点に置きます。これで、例は以下のようになります:

@c line-width ensures no break
@lilypond[quote,ragged-right,line-width=6\in]
rhMusic = \relative {
  \new Voice {
    r2 c''4.\( g8 |
    \once \override Tie.staff-position = #3.5
    bes1~ |
    \bar "||"
    \time 6/4
    bes2.\tempo "Moderato" r8
    \mergeDifferentlyHeadedOn
    \mergeDifferentlyDottedOn
    % 4 つのボイスの多声セクションの開始
    <<
      { c,8 d fis bes a }  % メイン ボイスの続き
      \new Voice {
        \voiceTwo
        c,8~ 2
      }
      \new Voice {
        \voiceThree
        s8 d2
      }
      \new Voice {
        \voiceFour
        s4 fis4.
      }
    >> |
    \mergeDifferentlyHeadedOff
    \mergeDifferentlyDottedOff
    g2.\)  % メイン ボイスの続き
  }
}

lhMusic = \relative {
  r2 <c' g ees>2( |
  <d g, d>1)\arpeggio |
  r2. d,,4 r4 r |
  r4
}

\score {
  \new PianoStaff <<
    \new Staff = "RH"  <<
      \key g \minor
      \rhMusic
    >>
    \new Staff = "LH" <<
      \key g \minor
      \clef "bass"
      \lhMusic
    >>
  >>
}
@end lilypond

オーバライドは 2 つの F シャープの音符をマージしましたが、@c
2 つの D をマージしませんでした。@c
なぜマージしなかったのでしょうか？@c
その答えは記譜法リファレンスの同じセクションにあります
-- マージされる音符は反対向きの符幹を持っていなくてはならず、@c
同じ音符列に 3 つ目の音符がある場合は 2 つの音符をマージさせることは@c
できません。@c
今回の例では、2 つの D は両方とも上向きの符幹を持っていて、@c
3 つ目の音符 -- C -- が存在します。@c
我々は @code{\stemDown} を用いて符幹の向きを変更する方法を知っていて、@c
記譜法リファレンスも C を移動させる方法について述べています --
@code{\shift} コマンドの 1 つを用いてシフトを行います。@c
しかし、どのシフトを行えばよいのでしょうか？@c
C はシフト off のボイス 2 の中にあり、2 つの D はボイス 1 とボイス 3 --
それぞれ、シフト off とシフト on -- の中にあります。@c
ですから、C が 2 つの D と衝突するのを避けるために、@c
@code{\shiftOnn} を用いて C を更にシフトさせる必要があります。@c
これらの変更を加えると、以下のようになります:

@cindex Tie, example of overriding (Tie をオーバライドする例)
@cindex staff-position property, example (staff-position プロパティの例)

@c line-width ensures no break
@lilypond[quote,verbatim,ragged-right,line-width=6\in]
rhMusic = \relative {
  \new Voice {
    r2 c''4.\( g8 |
    \once \override Tie.staff-position = #3.5
    bes1~ |
    \bar "||"
    \time 6/4
    bes2.\tempo "Moderato" r8
    \mergeDifferentlyHeadedOn
    \mergeDifferentlyDottedOn
    % 4 つのボイスの多声セクションの開始
    <<
      { c,8 d fis bes a }  % メイン ボイスの続き
      \new Voice {
        \voiceTwo
        % c2 をメインの音符列から外したため、
        % マージが機能します
        c,8~ \shiftOnn c2
      }
      \new Voice {
        \voiceThree
        % マージさせるために d2 の符幹を下向きにする必要があります
        s8 \stemDown d2
      }
      \new Voice {
        \voiceFour
        s4 fis4.
      }
    >> |
    \mergeDifferentlyHeadedOff
    \mergeDifferentlyDottedOff
    g2.\)  % メイン ボイスの続き
  }
}

lhMusic = \relative {
  r2 <c' g ees>2( |
  <d g, d>1)\arpeggio |
  r2. d,,4 r4 r |
  r4
}

\score {
  \new PianoStaff <<
    \new Staff = "RH"  <<
      \key g \minor
      \rhMusic
    >>
    \new Staff = "LH" <<
      \key g \minor
      \clef "bass"
      \lhMusic
    >>
  >>
}
@end lilypond

もうちょっとです。@c
残っている問題は 2 つだけです:
マージされた D の下向きの符幹はあるべきではなく、C は D の右側に配置した方が@c
良いということです。@c
以前に行った調整からこれらを行う方法を両方とも知っています:
符幹を透明にして、@code{force-hshift} プロパティを用いて C を移動させます。@c
ここで、最終結果を示します:

@cindex NoteColumn, example of overriding (NoteColumn をオーバライドする例)
@cindex force-hshift property, example (force-hshift プロパティの例)
@cindex Stem, example of overriding (Stem をオーバライドする例))
@cindex transparent property, example (transparent プロパティの例)

@c line-width ensures no break
@lilypond[quote,verbatim,ragged-right,line-width=6\in]
rhMusic = \relative {
  \new Voice {
    r2 c''4.\( g8 |
    \once \override Tie.staff-position = #3.5
    bes1~ |
    \bar "||"
    \time 6/4
    bes2.\tempo "Moderato" r8
    \mergeDifferentlyHeadedOn
    \mergeDifferentlyDottedOn
    % 4 つのボイスの多声セクションの開始
    <<
      { c,8 d fis bes a }  % メイン ボイスの続き
      \new Voice {
        \voiceTwo
        c,8~
        % マージされる音符の右にある c2 を再配置します
        \once \override NoteColumn.force-hshift = #1.0
        % c2 をメインの音符列から外したため、マージが機能します
        \shiftOnn
        c2
      }
      \new Voice {
        \voiceThree
        s8
        % マージさせるために d2 の符幹を下向きにする必要があります
        \stemDown
        % d2 の符幹を不可視にします
        \tweak Stem.transparent ##t
        d2
      }
      \new Voice {
        \voiceFour
        s4 fis4.
      }
    >> |
    \mergeDifferentlyHeadedOff
    \mergeDifferentlyDottedOff
    g2.\)  % メイン ボイスの続き
  }
}

lhMusic = \relative {
  r2 <c' g ees>2( |
  <d g, d>1)\arpeggio |
  r2. d,,4 r4 r |
  r4
}

\score {
  \new PianoStaff <<
    \new Staff = "RH"  <<
      \key g \minor
      \rhMusic
    >>
    \new Staff = "LH" <<
      \key g \minor
      \clef "bass"
      \lhMusic
    >>
  >>
}
@end lilypond


@need 2000
@node Further tweaking
@section 更なる調整


@node Other uses for tweaks
@subsection 調整のその他の使用方法

@cindex removing objects (オブジェクトを削除する)
@cindex objects, removing (オブジェクトを削除する)

@node Tying notes across voices
@unnumberedsubsubsec 異なるボイスの中にある音符をタイで結ぶ

@cindex tying notes across voices (異なるボイスの中にある音符をタイで結ぶ)

以下の例は異なるボイスの中にある音符をタイで結ぶ方法を示しています。@c
通常、タイで結べるのは同じボイスの中にある音符だけです。@c
2 つのボイスを使い、そのうちの 1 つにタイで結んだ音符を置きます:

@lilypond[quote]
<< { b'8~ 8\noBeam } \\ { b'8[ g'] } >>
@end lilypond

@noindent
そして、そのボイスの最初の上向き符幹と符尾を消します。@c
これで、タイはボイスをまたがっているように見えます:

@funindex \omit
@cindex Stem, example of overriding (Stem をオーバライドする例)
@cindex Flag, example of overriding (Flag をオーバライドする例)
@cindex @code{\omit}, example (@code{\omit} の例)
@cindex example of @code{\omit} (@code{\omit} の例)

@lilypond[quote,verbatim]
<<
  {
    \once \omit Stem
    \once \omit Flag
    b'8~ 8\noBeam
  }
\\
  { b'8[ g'] }
>>
@end lilypond

@morerefs
Learning Manual:
@ref{The once prefix},
@ref{The stencil property}.


@node Simulating a fermata in MIDI
@unnumberedsubsubsec MIDI でフェルマータをシミュレートする

@cindex stencil property, use of (stencil プロパティの使用方法)
@cindex fermata, implementing in MIDI (MIDI でフェルマータ を実装する)

譜外部オブジェクトを出力から削除しようとする場合、そのオブジェクトの
@code{transparent} プロパティではなく @code{stencil} プロパティを@c
オーバライドする方が通常は望ましいです。@c
あるオブジェクトの @code{stencil} プロパティを
@code{#f} にセットすると、@c
そのオブジェクトは出力から完全に削除されます。@c
このことは、削除されたオブジェクトがそのオブジェクトとの相対位置で@c
配置される他のオブジェクトの配置にまったく影響を及ぼさないということを@c
意味します。

例えば、MIDI 出力でフェルマータをシミュレートするためにメトロノーム設定を@c
変更したいとします。@c
その場合、メトロノーム記号を出力に表示させたくありません。@c
そして、それが 2 つのシステム (小節とその中にある表記) 間のスペースと、@c
譜上にある隣接する注釈の位置に影響を与えることを望みません。@c
そのため、そのメトロノーム記号の @code{stencil} プロパティを
@code{#f} にセットする方法が最良です。@c
ここで、2 つの手法の結果を示します:

@cindex MetronomeMark, example of overriding (MetronomeMark をオーバライドする例)
@cindex transparent property, example (transparent プロパティの例)

@lilypond[quote,verbatim,ragged-right]
\score {
  \relative {
    % Visible tempo marking
    \tempo 4=120
    a'4 a a
    \once \hide Score.MetronomeMark
    % Invisible tempo marking to lengthen fermata in MIDI
    \tempo 4=80
    a4\fermata |
    % New tempo for next section
    \tempo 4=100
    a4 a a a |
  }
  \layout { }
  \midi { }
}
@end lilypond

@cindex MetronomeMark, example of overriding (MetronomeMark をオーバライドする例)
@cindex stencil property, example (stencil プロパティの例)

@lilypond[quote,verbatim,ragged-right]
\score {
  \relative {
    % Visible tempo marking
    \tempo 4=120
    a'4 a a
    \once \omit Score.MetronomeMark
    % Invisible tempo marking to lengthen fermata in MIDI
    \tempo 4=80
    a4\fermata |
    % New tempo for next section
    \tempo 4=100
    a4 a a a |
  }
  \layout { }
  \midi { }
}
@end lilypond

@noindent
両方の手段とも、フェルマータ部分の演奏時間を伸ばすメトロノーム記号を@c
出力から削除していて、両方とも MIDI の演奏に必要な効果を与えています。@c
しかし、1 番目の例の透明なメトロノーム記号がそれに続く拍子指示を@c
上に押し上げているのに対して、2 番目のメトロノーム記号 (ステンシルが@c
削除されたもの) は押し上げていません。

@morerefs
音楽用語集:
@rglos{system}


@node Using variables for layout adjustments
@subsection レイアウトの調整のために変数を使用する

@cindex variables, using for overrides (オーバライドのために変数を使用する)
@cindex overrides, using variables for (オーバライドのために変数を使用する)
@cindex adjustments, using variables for (調整のために変数を使用する)
@cindex layout adjustments, using variables for (レイアウトの調整のために変数を使用する)

オーバライド コマンドはしばしば長く、入力するのが大変なものになります。@c
そして、それらは完全に正しく記述されなければなりません。@c
同じオーバライドが何度も使用される場合、それらを保持する変数を定義すると@c
非常に役に立ちます。

歌詞の中のある特定の単語をボールド イタリック体で譜刻することによって、@c
それらを強調したいと仮定します。@c
歌詞の中では、@code{\italic} と @code{\bold} は (書式を) 変更したい@c
単語や文と一緒に @code{\markup} ブロックの中に入れた場合にのみ@c
機能しますが、それを毎回入力するのは大変です。@c
埋め込む必要のある単語自体が、2 つのコマンドを簡単な変数を用いて使うことを@c
妨げます。@c
代替手段として、@code{\override} コマンドと @code{\revert} コマンドを@c
使うことはできないでしょうか？

@example
\override Lyrics.LyricText.font-shape = #'italic
\override Lyrics.LyricText.font-series = #'bold

\revert Lyrics.LyricText.font-shape
\revert Lyrics.LyricText.font-series
@end example

これらも、強調する必要のある単語がたくさんある場合、入力するのが@c
非常に大変です。@c
しかしながら、これらは 2 つの変数として定義することが@emph{でき}、@c
それらの変数で単語を囲むことによって使ってその単語を強調することが@c
@emph{できます}。@c
これらのオーバライドに変数を用いることのもう 1 つの利点は、@c
ドットの両側にスペースを置く必要が無いことです。@c
なぜなら、これらのオーバライドは @code{\lyricmode} の中で@c
直接解釈されるわけではないからです。@c
ここで変数を用いる例を挙げますが、実際には早く打ち込めるように@c
もっと短い変数名を使用します:

@cindex LyricText, example of overriding (LyricText をオーバライドする例)
@cindex font-shape property, example (font-shape プロパティの例)
@cindex font-series property, example (font-series プロパティの例)

@lilypond[quote,verbatim]
emphasize = {
  \override Lyrics.LyricText.font-shape = #'italic
  \override Lyrics.LyricText.font-series = #'bold
}

normal = {
  \revert Lyrics.LyricText.font-shape
  \revert Lyrics.LyricText.font-series
}

global = { \key c \major \time 4/4 \partial 4 }

SopranoMusic = \relative { c'4 | e4. e8 g4 g    | a4   a   g  }
AltoMusic    = \relative { c'4 | c4. c8 e4 e    | f4   f   e  }
TenorMusic   = \relative  { e4 | g4. g8 c4.  b8 | a8 b c d e4 }
BassMusic    = \relative  { c4 | c4. c8 c4 c    | f8 g a b c4 }

VerseOne = \lyricmode {
  E -- | ter -- nal \emphasize Fa -- ther, | \normal strong to save,
}

VerseTwo = \lyricmode {
  O | \once \emphasize Christ, whose voice the | wa -- ters heard,
}

VerseThree = \lyricmode {
  O | \emphasize Ho -- ly Spi -- rit, | \normal who didst brood
}

VerseFour = \lyricmode {
  O | \emphasize Tri -- ni -- ty \normal of | love and pow'r
}

\score {
  \new ChoirStaff <<
    \new Staff <<
      \clef "treble"
      \new Voice = "Soprano"  { \voiceOne \global \SopranoMusic }
      \new Voice = "Alto" { \voiceTwo \AltoMusic }
      \new Lyrics \lyricsto "Soprano" { \VerseOne }
      \new Lyrics \lyricsto "Soprano" { \VerseTwo }
      \new Lyrics \lyricsto "Soprano" { \VerseThree }
      \new Lyrics \lyricsto "Soprano" { \VerseFour }
    >>
    \new Staff <<
      \clef "bass"
      \new Voice = "Tenor" { \voiceOne \TenorMusic }
      \new Voice = "Bass"  { \voiceTwo \BassMusic }
    >>
  >>
}
@end lilypond


@node Style sheets
@subsection スタイル シート

LilyPond が作り出す出力にはさまざまな変更を加えることができます
(詳細は @ref{Tweaking output} を参照してください)。@c
しかしながら、調整を加えたい入力ファイルがたくさんあるとしたらどうでしょう？@c
また、単に調整を実際の音楽表記から分離したいとしたらどうでしょう？@c
これはとても簡単なことです。

以下の例を見てみましょう。@c
@code{#()} を持つ部分を理解できなくても心配しないでください。@c
@ref{Advanced tweaks with Scheme} で説明されています。

@lilypond[quote,verbatim,ragged-right]
mpdolce =
  \tweak self-alignment-X #-0.6
  #(make-dynamic-script
    #{ \markup { \dynamic mp \normal-text \italic \bold dolce } #})

inst =
#(define-music-function
     (string)
     (string?)
   #{ <>^\markup \bold \box #string #})

\relative {
  \tempo 4=50
  a'4.\mpdolce d8 cis4--\glissando a |
  b4 bes a2 |
  \inst "Clarinet"
  cis4.\< d8 e4 fis |
  g8(\! fis)-. e( d)-. cis2 |
}
@end lilypond

@code{mpdolce} と @code{tempoMark} の定義に手を加えてみることにします。@c
それらは望みの出力を作り出していますが、それらを別の楽曲で使いたいとします。@c
単純にそれらを各ファイルの先頭部分にカット＆ペーストすることもできますが、@c
わずらわしいです。@c
その方法では定義は依然として入力ファイルの中にあり、@c
私は個人的にすべての @code{#()} は何か醜いと感じます。@c
それらを他のファイルの中に隠すことにしましょう:

@example
%%% これを "definitions.ily" というファイル名で保存してください
mpdolce =
  \tweak self-alignment-X #-0.6
  #(make-dynamic-script
    #@{ \markup @{ \dynamic mp \normal-text \italic \bold dolce @} #@})

inst =
#(define-music-function
     (string)
     (string?)
   #@{ <>^\markup \bold \box #string #@})
@end example

音楽ファイルの先頭付近で @code{\include} コマンドを使ってこのファイルを@c
参照します。@c
(インクルードされるファイルをコンパイルされるメイン ファイルと区別するため、@c
拡張子 @file{.ily} を使っています。)
今度は音楽ファイルを変更しましょう
(このファイルを @file{"music.ly"} として保存してください)。

@c  We have to do this awkward example/lilypond-non-verbatim
@c  because we can't do the \include stuff in the manual.

@example
\include "definitions.ily"

\relative @{
  \tempo 4=50
  a'4.\mpdolce d8 cis4--\glissando a |
  b4 bes a2 |
  \inst "Clarinet"
  cis4.\< d8 e4 fis |
  g8(\! fis)-. e( d)-. cis2 |
@}
@end example

@lilypond[quote,ragged-right]
mpdolce =
  \tweak self-alignment-X #-0.6
  #(make-dynamic-script
    #{ \markup { \dynamic mp \normal-text \italic \bold dolce } #})

inst =
#(define-music-function
     (string)
     (string?)
   #{ <>^\markup \bold \box #string #})

\relative {
  \tempo 4=50
  a'4.\mpdolce d8 cis4--\glissando a |
  b4 bes a2 |
  \inst "Clarinet"
  cis4.\< d8 e4 fis |
  g8(\! fis)-. e( d)-. cis2 |
}
@end lilypond

これで前よりも良くなりましたが、いくつか変更を加えることにします。@c
グリッサンド (訳者: 第 1 小節の C シャープと A の間) は見え難いので、@c
もっと太く、符頭に近づけます。@c
メトロノーム記号を、最初の音符の上ではなく、@c
音部記号の上に持ってきます。@c
最後に、私の作曲の先生は @q{C} 拍子記号を嫌っているので、@c
@q{4/4} に変更した方が良さそうです。

@file{music.ly} には変更を加えないでください。@c
@file{definitions.ily} を以下のように書き換えます:

@example
%%%  definitions.ily
mpdolce =
  \tweak self-alignment-X #-0.6
  #(make-dynamic-script
    #@{ \markup @{ \dynamic mp \normal-text \italic \bold dolce @} #@})

inst =
#(define-music-function
     (string)
     (string?)
   #@{ <>^\markup \bold \box #string #@})

\layout@{
  \context @{
    \Score
    \override MetronomeMark.extra-offset = #'(-5 . 0)
    \override MetronomeMark.padding = #'3
  @}
  \context @{
    \Staff
    \override TimeSignature.style = #'numbered
  @}
  \context @{
    \Voice
    \override Glissando.thickness = #3
    \override Glissando.gap = #0.1
  @}
@}
@end example

@lilypond[quote,ragged-right]
mpdolce =
  \tweak self-alignment-X #-0.6
  #(make-dynamic-script
    #{ \markup { \dynamic mp \normal-text \italic \bold dolce } #})

inst =
#(define-music-function
     (string)
     (string?)
   #{ <>^\markup \bold \box #string #})

\layout{
  \context {
    \Score
    \override MetronomeMark.extra-offset = #'(-5 . 0)
    \override MetronomeMark.padding = #'3
  }
  \context {
    \Staff
    \override TimeSignature.style = #'numbered
  }
  \context {
    \Voice
    \override Glissando.thickness = #3
    \override Glissando.gap = #0.1
  }
}

\relative {
  \tempo 4=50
  a'4.\mpdolce d8 cis4--\glissando a |
  b4 bes a2 |
  \inst "Clarinet"
  cis4.\< d8 e4 fis |
  g8(\! fis)-. e( d)-. cis2 |
}
@end lilypond

もっと良くなりました！@c
今度はこれを公表したいとします。@c
私の作曲の先生は @q{C} 拍子記号を嫌っていますが、@c
私はそちらを好みます。@c
現在の @code{definitions.ily} を @code{web-publish.ily} にコピーして、@c
それにを変更を加えてみましょう。@c
この音楽はスクリーンに表示される PDF を作り出すことを意図したものなので、@c
出力のフォントを全体に大きくすることにします。

@example
%%%  web-publish.ily
mpdolce =
  \tweak self-alignment-X #-0.6
  #(make-dynamic-script
    #@{ \markup @{ \dynamic mp \normal-text \italic \bold dolce @} #@})

inst =
#(define-music-function
     (string)
     (string?)
   #@{ <>^\markup \bold \box #string #@})

#(set-global-staff-size 23)

\layout@{
  \context @{
    \Score
    \override MetronomeMark.extra-offset = #'(-5 . 0)
    \override MetronomeMark.padding = #'3
  @}
  \context @{
    \Staff
  @}
  \context @{
    \Voice
    \override Glissando.thickness = #3
    \override Glissando.gap = #0.1
  @}
@}
@end example

@lilypond[quote,ragged-right]
mpdolce =
  \tweak self-alignment-X #-0.6
  #(make-dynamic-script
    #{ \markup { \dynamic mp \normal-text \italic \bold dolce } #})

inst =
#(define-music-function
     (string)
     (string?)
   #{ <>^\markup \bold \box #string #})

#(set-global-staff-size 23)

\layout{
  \context { \Score
    \override MetronomeMark.extra-offset = #'(-5 . 0)
    \override MetronomeMark.padding = #'3
  }
  \context { \Voice
    \override Glissando.thickness = #3
    \override Glissando.gap = #0.1
  }
}

\relative {
  \tempo 4=50
  a'4.\mpdolce d8 cis4--\glissando a |
  b4 bes a2 |
  \inst "Clarinet"
  cis4.\< d8 e4 fis |
  g8(\! fis)-. e( d)-. cis2 |
}
@end lilypond

音楽ファイルの中では、単に @code{\include "definitions.ily"} を
@code{\include "web-publish.ily"} に置き換えるだけです。@c
もちろん、これをもっと便利なようにすることができます。@c
@file{definitions.ily} ファイルには
@code{mpdolce} と @code{tempoMark} の定義だけを持たせて、@c
@file{web-publish.ily} ファイルには@c
上で記述した @code{\layout} セクションだけを持たせ、@c
@file{university.ily} ファイルには@c
私の先生の好む出力を作り出すための調整だけを持たせます。@c
@file{music.ly} の先頭部分は以下のようになります:

@example
\include "definitions.ily"

%%%  以下の 2 行のどちらか片方のコメントを外してください！
\include "web-publish.ily"
%\include "university.ily"
@end example

このアプローチは、@c
あなたがパーツ一式を作っているだけだとしても役に立つ可能性があります。@c
私は自分のプロジェクトのために@c
半ダースの @q{スタイル シート} ファイルを使います。@c
私はそれぞれの音楽ファイルを
@code{\include "../global.ily"} で始め、@c
@file{gloval.ily} には以下の内容を記述しています:

@example
%%%   global.ily
\version @w{"@version{}"}

#(ly:set-option 'point-and-click #f)

\include "../init/init-defs.ly"
\include "../init/init-layout.ly"
\include "../init/init-headers.ly"
\include "../init/init-paper.ly"
@end example


@node Other sources of information
@subsection その他の情報源

内部リファレンスは LilyPond についての多くの情報を持っていますが、@c
LilyPond の内部ファイルを調べることによって@c
さらに多くの情報を収集することができます。@c
内部ファイルを探究するには、@c
まずあなたの使っているシステム特有のディレクトリを見つけ出す必要があります。@c
このディレクトリの場所は、(a) あなたが lilypond.org からコンパイル済みの@c
バイナリをダウンロードすることによって LilyPond を手に入れたのか、@c
それとも、パッケージ マネージャから LilyPond をインストールした
(つまり、GNU/Linux と一緒に配布されたか、fink や cygwin でインストールされた)
のか、(b) LilyPond はどの OS 上で使用されているのか、に依存します:

@subsubsubheading lilypond.org からダウンロードした

@itemize @bullet
@item GNU/Linux

@example
@file{@var{INSTALLDIR}/lilypond/usr/share/lilypond/current/}
@end example
に進んでください

@item MacOS X

@example
@file{@var{INSTALLDIR}/LilyPond.app/Contents/Resources/share/lilypond/current/}
@end example
に進んでください。@c
ターミナルからこのディレクトリへ @code{cd} で移動するか、@c
LilyPond アプリケーション上でコントロール クリックして
@q{Show Package Contents} を選択します。

@item Windows

@example
@file{@var{INSTALLDIR}/LilyPond/usr/share/lilypond/current/}
@end example
に進んでください。Windows Explorer を使います。

@end itemize

@subsubsubheading パッケージ マネージャからインストールした、あるいは、ソースからコンパイルした

@file{@var{PREFIX}/share/lilypond/@var{X.Y.Z}/} に進んでください。@c
@var{PREFIX} はパッケージ マネージャか @code{configure} スクリプトによって@c
セットされるものであり、@var{X.Y.Z} は LilyPond のバージョン番号です。

@smallspace

このディレクトリの中に 2 つの興味深いサブディレクトリがあります:

@itemize
@item @file{ly/} - LilyPond フォーマットに関するファイルを保持しています
@item @file{scm/} -Scheme フォーマットに関するファイルを保持しています
@end itemize

@file{ly/} の中にあるファイルから見ていきましょう。@c
@file{ly/property-init.ly} をテキスト エディタで開いてください。@c
エディタはあなたが普段 @code{.ly} ファイルを編集するために使っているもので@c
結構です。@c
このファイルは標準の LilyPond 定義済みコマンド
-- @code{\tieUp} や @code{\slurDotted} など
-- のすべての定義を保持しています。@c
1 つまたは複数の @code{\override} コマンドを保持している@c
変数の定義以外のものはないということがわかるでしょう。@c
例えば、@code{\tieDotted} は以下のように定義されています:

@example
tieDotted = @{
  \override Tie.dash-period = #0.75
  \override Tie.dash-fraction = #0.1
@}
@end example

あなたがこれらのデフォルト値を好まない場合、これらの定義済みコマンドを@c
容易に再定義することができます --
他の変数と同様に、入力ファイルの先頭で定義します。

以下のファイルは @file{ly/} で見つかる有用なファイルです:

@multitable @columnfractions .4 .6
@headitem ファイル名
  @tab 内容
@item @file{ly/engraver-init.ly}
  @tab エングラーバ コンテキストの定義
@item @file{ly/paper-defaults-init.ly}
  @tab 紙面関係のデフォルトの仕様
@item @file{ly/performer-init.ly}
  @tab パフォーマ コンテキストの定義
@item @file{ly/property-init.ly}
  @tab すべての共通定義済みコマンドの定義
@item @file{ly/spanner-init.ly}
  @tab スパナ関係の定義済みコマンドの定義
@end multitable

他の設定 (マークアップ コマンドの定義など) は
@code{.scm} (Scheme) ファイルとして保存されています。@c
Scheme プログラミング言語は、LilyPond 内部処理へのプログラム可能な@c
インタフェイスを提供するために使用されます。@c
これらのファイルについての詳しい説明は、Scheme 言語についての知識が@c
必要となるため、このマニュアルの範囲外です。@c
Scheme 言語とこれらのファイルを理解するには、十分な知識や時間が@c
必要であるということを知っておくべきです
(@rextend{Scheme tutorial} を参照してください)。

あなたがこの知識を持っているのなら、興味を持つかもしれない Scheme ファイルは@c
以下のものです:

@multitable @columnfractions .4 .6
@headitem ファイル名
  @tab 内容
@item @file{scm/auto-beam.scm}
  @tab サブ 連桁のデフォルト (訳者: 8 分音符には連桁だけが使用され、@c
16 分音符やそれよりも短い音符には連桁とサブ 連桁が使われるのだと思います)
@item @file{scm/define-grobs.scm}
  @tab Grob (グラフィカル オブジェクト) プロパティのデフォルト設定
@item @file{scm/define-markup-commands.scm}
  @tab すべてのマークアップ コマンドの仕様
@item @file{scm/midi.scm}
  @tab MIDI 出力のデフォルト設定
@item @file{scm/output-lib.scm}
  @tab フレット、色、臨時記号、小節線などの見た目に影響を与える設定
@item @file{scm/parser-clef.scm}
  @tab サポートされる音部記号の定義
@item @file{scm/script.scm}
  @tab アーティキュレーションのデフォルト設定
@end multitable


@node Advanced tweaks with Scheme
@subsection Scheme を用いた高度な調整

@code{\override} と @code{\tweak} コマンドを用いることで@c
多くのことが可能になりますが、LilyPond のアクションを変更するもっと強力な手段が
LilyPond 内部処理へのプログラム可能なインタフェイスを通じて利用可能です。@c
Scheme プログラミング言語で書かれたコードは LilyPond の内部処理に@c
直接組み込むことができます。@c
もちろん、それを行うには Scheme プログラミングについての基礎知識が必要であり、@c
その手引きが @rextend{Scheme tutorial} で提供されています。

多くの実現可能なことの 1 つの例としては、プロパティに定数をセットする代わりに
Scheme プロシージャをセットすることができます。@c
このプロパティが LilyPond によってアクセスされたときに、@c
このプロシージャが呼び出されます。@c
このプロシージャが呼び出されたときに、このプロシージャによって決定された@c
値を動的にそのプロパティにセットすることができます。@c
以下の例では、符頭にその音符の譜上での位置に従って色を付けています:

@cindex x11-color function, example of using (x11-color 関数の使用方法)
@cindex NoteHead, example of overriding (NoteHead をオーバライドする例)
@cindex color property, setting to Scheme procedure (Scheme プロシージャに color プロパティをセットする)

@lilypond[quote,verbatim,ragged-right]
#(define (color-notehead grob)
   "Color the notehead according to its position on the staff."
   (let ((mod-position (modulo (ly:grob-property grob 'staff-position)
                               7)))
     (case mod-position
       ;;   Return rainbow colors
       ((1) (x11-color 'red    ))  ; for C
       ((2) (x11-color 'orange ))  ; for D
       ((3) (x11-color 'yellow ))  ; for E
       ((4) (x11-color 'green  ))  ; for F
       ((5) (x11-color 'blue   ))  ; for G
       ((6) (x11-color 'purple ))  ; for A
       ((0) (x11-color 'violet ))  ; for B
       )))

\relative {
  % Arrange to obtain color from color-notehead procedure
  \override NoteHead.color = #color-notehead
  a2 b | c2 d | e2 f | g2 a |
}
@end lilypond

@rextend{Callback functions} に、これらのプログラム可能なインタフェイスの@c
使い方を示している例がもっとあります。
